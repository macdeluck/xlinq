<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>xLinq: xlinq Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xLinq
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xlinq Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IEnumerator.html">IEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for enumerator.  <a href="classxlinq_1_1IEnumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IBidirectionalEnumerator.html">IBidirectionalEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for bidirectional enumerator.  <a href="classxlinq_1_1IBidirectionalEnumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IRandomAccessEnumerator.html">IRandomAccessEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for random access enumerator.  <a href="classxlinq_1_1IRandomAccessEnumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IEnumerable.html">IEnumerable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for enumerable.  <a href="classxlinq_1_1IEnumerable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IBidirectionalEnumerable.html">IBidirectionalEnumerable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for bidirectional enumerable.  <a href="classxlinq_1_1IBidirectionalEnumerable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html">IRandomAccessEnumerable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for random access enumerable.  <a href="classxlinq_1_1IRandomAccessEnumerable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all exceptions.  <a href="classxlinq_1_1Exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IterationNotStartedException.html">IterationNotStartedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error indicating, that iteration was not started yet.  <a href="classxlinq_1_1IterationNotStartedException.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IterationFinishedException.html">IterationFinishedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error indicating, that iteration has been already finished.  <a href="classxlinq_1_1IterationFinishedException.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4f2c6ff34dff175b89b7b0779e131b91"><td class="memTemplParams" colspan="2">template&lt;typename TValue , typename TBuilder &gt; </td></tr>
<tr class="memitem:a4f2c6ff34dff175b89b7b0779e131b91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a4f2c6ff34dff175b89b7b0779e131b91">operator&gt;&gt;</a> (std::shared_ptr&lt; TValue &gt; obj, TBuilder builder) -&gt; decltype(build(obj, builder))</td></tr>
<tr class="memdesc:a4f2c6ff34dff175b89b7b0779e131b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nice syntax operator for executing xlinq command.  <a href="#a4f2c6ff34dff175b89b7b0779e131b91">More...</a><br/></td></tr>
<tr class="separator:a4f2c6ff34dff175b89b7b0779e131b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c51dfbb405e91dbf589ba4864d700c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GetEnumeratorBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a29c51dfbb405e91dbf589ba4864d700c">getEnumerator</a> ()</td></tr>
<tr class="memdesc:a29c51dfbb405e91dbf589ba4864d700c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function extracting enumerator from enumerable.  <a href="#a29c51dfbb405e91dbf589ba4864d700c">More...</a><br/></td></tr>
<tr class="separator:a29c51dfbb405e91dbf589ba4864d700c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584dee55e0e1bb36c76f963eadddd910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GetEndEnumeratorBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a584dee55e0e1bb36c76f963eadddd910">getEndEnumerator</a> ()</td></tr>
<tr class="memdesc:a584dee55e0e1bb36c76f963eadddd910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function extracting end enumerator from bidirectional enumerable.  <a href="#a584dee55e0e1bb36c76f963eadddd910">More...</a><br/></td></tr>
<tr class="separator:a584dee55e0e1bb36c76f963eadddd910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff22f546b38f9e0a88fd478b8710b6c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GetEnumeratorAtBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aff22f546b38f9e0a88fd478b8710b6c0">getEnumeratorAt</a> (int elementIndex)</td></tr>
<tr class="memdesc:aff22f546b38f9e0a88fd478b8710b6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function extracting enumerator at given position from random access enumerable.  <a href="#aff22f546b38f9e0a88fd478b8710b6c0">More...</a><br/></td></tr>
<tr class="separator:aff22f546b38f9e0a88fd478b8710b6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4334e89a57a62a0fb827ab027bb54795"><td class="memTemplParams" colspan="2">template&lt;typename TElem , int SIZE&gt; </td></tr>
<tr class="memitem:a4334e89a57a62a0fb827ab027bb54795"><td class="memTemplItemLeft" align="right" valign="top">internal::_ConcatRandomAccessBuilder<br class="typebreak"/>
&lt; TElem &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a4334e89a57a62a0fb827ab027bb54795">concat</a> (TElem(&amp;array)[SIZE])</td></tr>
<tr class="memdesc:a4334e89a57a62a0fb827ab027bb54795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function concatenating array with other enumerable into single collection.  <a href="#a4334e89a57a62a0fb827ab027bb54795">More...</a><br/></td></tr>
<tr class="separator:a4334e89a57a62a0fb827ab027bb54795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad102ec5f3d28670c209fd553e424f5a4"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:ad102ec5f3d28670c209fd553e424f5a4"><td class="memTemplItemLeft" align="right" valign="top">internal::ConcatBuilderSelector<br class="typebreak"/>
&lt; TContainer, typename <br class="typebreak"/>
TContainer::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ad102ec5f3d28670c209fd553e424f5a4">concat</a> (TContainer &amp;container)</td></tr>
<tr class="memdesc:ad102ec5f3d28670c209fd553e424f5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function concatenating container with other enumerable into single collection.  <a href="#ad102ec5f3d28670c209fd553e424f5a4">More...</a><br/></td></tr>
<tr class="separator:ad102ec5f3d28670c209fd553e424f5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec6bf504683e98b901859ac21ab214a"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:a2ec6bf504683e98b901859ac21ab214a"><td class="memTemplItemLeft" align="right" valign="top">internal::ConcatBuilderSelector<br class="typebreak"/>
&lt; TContainer, typename <br class="typebreak"/>
TContainer::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a2ec6bf504683e98b901859ac21ab214a">concat</a> (TContainer *container)</td></tr>
<tr class="memdesc:a2ec6bf504683e98b901859ac21ab214a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function concatenating container pointer with other enumerable into single collection.  <a href="#a2ec6bf504683e98b901859ac21ab214a">More...</a><br/></td></tr>
<tr class="separator:a2ec6bf504683e98b901859ac21ab214a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8a8f161ad682b6c08d59b0fc09cb2a"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:a3c8a8f161ad682b6c08d59b0fc09cb2a"><td class="memTemplItemLeft" align="right" valign="top">internal::ConcatBuilderSelector<br class="typebreak"/>
&lt; TContainer, typename <br class="typebreak"/>
TContainer::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a3c8a8f161ad682b6c08d59b0fc09cb2a">concat</a> (std::shared_ptr&lt; TContainer &gt; container)</td></tr>
<tr class="memdesc:a3c8a8f161ad682b6c08d59b0fc09cb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function concatenating container shared pointer with other enumerable into single collection.  <a href="#a3c8a8f161ad682b6c08d59b0fc09cb2a">More...</a><br/></td></tr>
<tr class="separator:a3c8a8f161ad682b6c08d59b0fc09cb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff0586eed8fd9d546950818aa40fb11"><td class="memTemplParams" colspan="2">template&lt;typename TEnumerable &gt; </td></tr>
<tr class="memitem:afff0586eed8fd9d546950818aa40fb11"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#afff0586eed8fd9d546950818aa40fb11">concat</a> (std::shared_ptr&lt; TEnumerable &gt; enumerable) -&gt; typename internal::ConcatBuilderSelectorHelper&lt; decltype(<a class="el" href="namespacexlinq.html#aa014597a96853a8eb464f63a8e2560db">from</a>(enumerable)), typename TEnumerable::ElemType &gt;::builder</td></tr>
<tr class="memdesc:afff0586eed8fd9d546950818aa40fb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function concatenating two enumerables into single collection.  <a href="#afff0586eed8fd9d546950818aa40fb11">More...</a><br/></td></tr>
<tr class="separator:afff0586eed8fd9d546950818aa40fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec31d8cf9c65eb9f1b5065f7f28bd68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_CountBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a9ec31d8cf9c65eb9f1b5065f7f28bd68">count</a> ()</td></tr>
<tr class="memdesc:a9ec31d8cf9c65eb9f1b5065f7f28bd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements in collection.  <a href="#a9ec31d8cf9c65eb9f1b5065f7f28bd68">More...</a><br/></td></tr>
<tr class="separator:a9ec31d8cf9c65eb9f1b5065f7f28bd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921234e8bf3e9579a5aa0a81700c5660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_FirstBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a921234e8bf3e9579a5aa0a81700c5660">first</a> ()</td></tr>
<tr class="memdesc:a921234e8bf3e9579a5aa0a81700c5660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts first element of collection.  <a href="#a921234e8bf3e9579a5aa0a81700c5660">More...</a><br/></td></tr>
<tr class="separator:a921234e8bf3e9579a5aa0a81700c5660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96961d816001f1a21a3de8483297b6b4"><td class="memTemplParams" colspan="2">template&lt;typename TElem , int SIZE&gt; </td></tr>
<tr class="memitem:a96961d816001f1a21a3de8483297b6b4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a96961d816001f1a21a3de8483297b6b4">from_array</a> (TElem(&amp;array)[SIZE]) -&gt; std::shared_ptr&lt; <a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html">IRandomAccessEnumerable</a>&lt; typename std::remove_all_extents&lt; typename std::remove_reference&lt; decltype(array)&gt;::type &gt;::type &gt;&gt;</td></tr>
<tr class="separator:a96961d816001f1a21a3de8483297b6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa014597a96853a8eb464f63a8e2560db"><td class="memTemplParams" colspan="2">template&lt;typename TElem , int SIZE&gt; </td></tr>
<tr class="memitem:aa014597a96853a8eb464f63a8e2560db"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html">IRandomAccessEnumerable</a><br class="typebreak"/>
&lt; TElem &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aa014597a96853a8eb464f63a8e2560db">from</a> (TElem(&amp;array)[SIZE])</td></tr>
<tr class="memdesc:aa014597a96853a8eb464f63a8e2560db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from fixed size array.  <a href="#aa014597a96853a8eb464f63a8e2560db">More...</a><br/></td></tr>
<tr class="separator:aa014597a96853a8eb464f63a8e2560db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09854bf591e82bd4a0a1b09e4b5ff6e"><td class="memTemplParams" colspan="2">template&lt;typename TElem , int SIZE&gt; </td></tr>
<tr class="memitem:ad09854bf591e82bd4a0a1b09e4b5ff6e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html">IRandomAccessEnumerable</a><br class="typebreak"/>
&lt; TElem &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ad09854bf591e82bd4a0a1b09e4b5ff6e">from</a> (std::array&lt; TElem, SIZE &gt; &amp;array)</td></tr>
<tr class="memdesc:ad09854bf591e82bd4a0a1b09e4b5ff6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from new standard fixed size array.  <a href="#ad09854bf591e82bd4a0a1b09e4b5ff6e">More...</a><br/></td></tr>
<tr class="separator:ad09854bf591e82bd4a0a1b09e4b5ff6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9338e7aee5cc2f78c4caf9109b4b6a08"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:a9338e7aee5cc2f78c4caf9109b4b6a08"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a9338e7aee5cc2f78c4caf9109b4b6a08">from</a> (TContainer &amp;container) -&gt; std::shared_ptr&lt; typename internal::EnumerableTypeSelector&lt; typename internal::StlEnumerableSelector&lt; TContainer, typename TContainer::value_type &gt;::type &gt;::type &gt;</td></tr>
<tr class="memdesc:a9338e7aee5cc2f78c4caf9109b4b6a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from STL container.  <a href="#a9338e7aee5cc2f78c4caf9109b4b6a08">More...</a><br/></td></tr>
<tr class="separator:a9338e7aee5cc2f78c4caf9109b4b6a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871b0d2fcbb5f1f19240bf4d322ed3fd"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:a871b0d2fcbb5f1f19240bf4d322ed3fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a871b0d2fcbb5f1f19240bf4d322ed3fd">from</a> (TContainer *container) -&gt; std::shared_ptr&lt; typename internal::EnumerableTypeSelector&lt; typename internal::StlEnumerableSelector&lt; TContainer, typename TContainer::value_type &gt;::type &gt;::type &gt;</td></tr>
<tr class="memdesc:a871b0d2fcbb5f1f19240bf4d322ed3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from pointer to STL container.  <a href="#a871b0d2fcbb5f1f19240bf4d322ed3fd">More...</a><br/></td></tr>
<tr class="separator:a871b0d2fcbb5f1f19240bf4d322ed3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54a43688decc1901d409d28d62f501a"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:aa54a43688decc1901d409d28d62f501a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aa54a43688decc1901d409d28d62f501a">from</a> (std::shared_ptr&lt; TContainer &gt; container) -&gt; std::shared_ptr&lt; typename internal::EnumerableTypeSelector&lt; typename internal::StlSharedPointerEnumerableSelector&lt; TContainer, typename TContainer::value_type &gt;::type &gt;::type &gt;</td></tr>
<tr class="memdesc:aa54a43688decc1901d409d28d62f501a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from shared pointer to STL container.  <a href="#aa54a43688decc1901d409d28d62f501a">More...</a><br/></td></tr>
<tr class="separator:aa54a43688decc1901d409d28d62f501a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543625f413c5d16601cc251b78eac562"><td class="memTemplParams" colspan="2">template&lt;typename TEnumerable &gt; </td></tr>
<tr class="memitem:a543625f413c5d16601cc251b78eac562"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; typename <br class="typebreak"/>
internal::EnumerableFilterHelper<br class="typebreak"/>
&lt; TEnumerable, typename <br class="typebreak"/>
TEnumerable::ElemType &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a543625f413c5d16601cc251b78eac562">from</a> (std::shared_ptr&lt; TEnumerable &gt; enumerable)</td></tr>
<tr class="memdesc:a543625f413c5d16601cc251b78eac562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from shared pointer to enumerable.  <a href="#a543625f413c5d16601cc251b78eac562">More...</a><br/></td></tr>
<tr class="separator:a543625f413c5d16601cc251b78eac562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c906f78dfc6d4f875df1328acc010b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GatherBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ad8c906f78dfc6d4f875df1328acc010b">gather</a> ()</td></tr>
<tr class="memdesc:ad8c906f78dfc6d4f875df1328acc010b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers elements of collection.  <a href="#ad8c906f78dfc6d4f875df1328acc010b">More...</a><br/></td></tr>
<tr class="separator:ad8c906f78dfc6d4f875df1328acc010b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c0c48c2ddd55173be4d492f7b72590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_LastBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a73c0c48c2ddd55173be4d492f7b72590">last</a> ()</td></tr>
<tr class="memdesc:a73c0c48c2ddd55173be4d492f7b72590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts last element of collection.  <a href="#a73c0c48c2ddd55173be4d492f7b72590">More...</a><br/></td></tr>
<tr class="separator:a73c0c48c2ddd55173be4d492f7b72590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab738e44970df0cc013b01175278396ff"><td class="memTemplParams" colspan="2">template&lt;typename TSelector &gt; </td></tr>
<tr class="memitem:ab738e44970df0cc013b01175278396ff"><td class="memTemplItemLeft" align="right" valign="top">internal::_SelectBuilder<br class="typebreak"/>
&lt; TSelector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ab738e44970df0cc013b01175278396ff">select</a> (TSelector selector)</td></tr>
<tr class="memdesc:ab738e44970df0cc013b01175278396ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts collection elements from one form to another.  <a href="#ab738e44970df0cc013b01175278396ff">More...</a><br/></td></tr>
<tr class="separator:ab738e44970df0cc013b01175278396ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fb6711f909024ee9f1b37f006858ad"><td class="memTemplParams" colspan="2">template&lt;typename TSelector &gt; </td></tr>
<tr class="memitem:a56fb6711f909024ee9f1b37f006858ad"><td class="memTemplItemLeft" align="right" valign="top">internal::_SelectManyBuilder<br class="typebreak"/>
&lt; TSelector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a56fb6711f909024ee9f1b37f006858ad">select_many</a> (TSelector selector)</td></tr>
<tr class="memdesc:a56fb6711f909024ee9f1b37f006858ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens collection by concatenating subelements of original collection.  <a href="#a56fb6711f909024ee9f1b37f006858ad">More...</a><br/></td></tr>
<tr class="separator:a56fb6711f909024ee9f1b37f006858ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439f2d6992edc6ceb1d4457168f7d7b7"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:a439f2d6992edc6ceb1d4457168f7d7b7"><td class="memTemplItemLeft" align="right" valign="top">internal::_WhereBuilder<br class="typebreak"/>
&lt; TPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a439f2d6992edc6ceb1d4457168f7d7b7">where</a> (TPredicate predicate)</td></tr>
<tr class="memdesc:a439f2d6992edc6ceb1d4457168f7d7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters elements of collection using predicate.  <a href="#a439f2d6992edc6ceb1d4457168f7d7b7">More...</a><br/></td></tr>
<tr class="separator:a439f2d6992edc6ceb1d4457168f7d7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4334e89a57a62a0fb827ab027bb54795"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem , int SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::_ConcatRandomAccessBuilder&lt;TElem&gt; xlinq::concat </td>
          <td>(</td>
          <td class="paramtype">TElem(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[SIZE]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function concatenating array with other enumerable into single collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Enumerable which will be concatenated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of concat expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ad102ec5f3d28670c209fd553e424f5a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::ConcatBuilderSelector&lt;TContainer, typename TContainer::value_type&gt;::type xlinq::concat </td>
          <td>(</td>
          <td class="paramtype">TContainer &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function concatenating container with other enumerable into single collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Enumerable which will be concatenated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of concat expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ec6bf504683e98b901859ac21ab214a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::ConcatBuilderSelector&lt;TContainer, typename TContainer::value_type&gt;::type xlinq::concat </td>
          <td>(</td>
          <td class="paramtype">TContainer *&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function concatenating container pointer with other enumerable into single collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Enumerable which will be concatenated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of concat expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c8a8f161ad682b6c08d59b0fc09cb2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::ConcatBuilderSelector&lt;TContainer, typename TContainer::value_type&gt;::type xlinq::concat </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TContainer &gt;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function concatenating container shared pointer with other enumerable into single collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Enumerable which will be concatenated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of concat expression. </dd></dl>

</div>
</div>
<a class="anchor" id="afff0586eed8fd9d546950818aa40fb11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEnumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::concat </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TEnumerable &gt;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td> -&gt; typename internal::ConcatBuilderSelectorHelper&lt;decltype(from(enumerable)), typename TEnumerable::ElemType&gt;::builder
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function concatenating two enumerables into single collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Enumerable which will be concatenated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of concat expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ec31d8cf9c65eb9f1b5065f7f28bd68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_CountBuilder xlinq::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of elements in collection. </p>
<p>This function may be used to count number of elements in collection. It does not count elements if the collection implements <a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html" title="Interface for random access enumerable. ">IRandomAccessEnumerable</a> interface. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of first expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a921234e8bf3e9579a5aa0a81700c5660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_FirstBuilder xlinq::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts first element of collection. </p>
<p>This function may be used to extract first element of collection. It will throw <a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a> if collection contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of first expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a871b0d2fcbb5f1f19240bf4d322ed3fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::from </td>
          <td>(</td>
          <td class="paramtype">TContainer *&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; std::shared_ptr&lt;typename internal::EnumerableTypeSelector&lt;typename internal::StlEnumerableSelector&lt;TContainer, typename TContainer::value_type&gt;::type&gt;::type&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from pointer to STL container. </p>
<p>This function may be used to create enumerable from pointer to STL container. It is implemented using deffered execution so traversing of the collection will wait until its next element will be requested. Please note, that enumeration will fail if container will be deallocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Source STL container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enumerable from container. </dd></dl>

</div>
</div>
<a class="anchor" id="a543625f413c5d16601cc251b78eac562"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEnumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;typename internal::EnumerableFilterHelper&lt;TEnumerable, typename TEnumerable::ElemType&gt;::type&gt; xlinq::from </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TEnumerable &gt;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from shared pointer to enumerable. </p>
<p>This function returns cleaned type from given enumerable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Source enumerable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="aa54a43688decc1901d409d28d62f501a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::from </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TContainer &gt;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; std::shared_ptr&lt;typename internal::EnumerableTypeSelector&lt;typename internal::StlSharedPointerEnumerableSelector&lt;TContainer, typename TContainer::value_type&gt;::type&gt;::type&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from shared pointer to STL container. </p>
<p>This function may be used to create enumerable from shared pointer to STL container. It is implemented using deffered execution so traversing of the collection will wait until its next element will be requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Source STL container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enumerable from container. </dd></dl>

</div>
</div>
<a class="anchor" id="a9338e7aee5cc2f78c4caf9109b4b6a08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::from </td>
          <td>(</td>
          <td class="paramtype">TContainer &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; std::shared_ptr&lt;typename internal::EnumerableTypeSelector&lt;typename internal::StlEnumerableSelector&lt;TContainer, typename TContainer::value_type&gt;::type&gt;::type&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from STL container. </p>
<p>This function may be used to create enumerable from STL container. It is implemented using deffered execution so traversing of the container will wait until its next element will be requested. Please note, that enumeration will fail if container will be deallocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Source container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enumerable from container. </dd></dl>

</div>
</div>
<a class="anchor" id="aa014597a96853a8eb464f63a8e2560db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem , int SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html">IRandomAccessEnumerable</a>&lt;TElem&gt; &gt; xlinq::from </td>
          <td>(</td>
          <td class="paramtype">TElem(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[SIZE]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from fixed size array. </p>
<p>This function may be used to create enumerable from fixed size array. It is implemented using deffered execution so traversing of the array will wait until its next element will be requested. Please note, that enumeration will fail if array will be deallocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Source fixed size array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enumerable from array. </dd></dl>

</div>
</div>
<a class="anchor" id="ad09854bf591e82bd4a0a1b09e4b5ff6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem , int SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html">IRandomAccessEnumerable</a>&lt;TElem&gt; &gt; xlinq::from </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; TElem, SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from new standard fixed size array. </p>
<p>This function may be used to create enumerable from fixed size array. It is implemented using deffered execution so traversing of the array will wait until its next element will be requested. Please note, that enumeration will fail if array will be deallocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Source fixed size array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enumerable from array. </dd></dl>

</div>
</div>
<a class="anchor" id="a96961d816001f1a21a3de8483297b6b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem , int SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::from_array </td>
          <td>(</td>
          <td class="paramtype">TElem(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[SIZE]</td><td>)</td>
          <td> -&gt; std::shared_ptr&lt;IRandomAccessEnumerable&lt;typename std::remove_all_extents&lt;typename std::remove_reference&lt;decltype(array)&gt;::type&gt;::type&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8c906f78dfc6d4f875df1328acc010b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GatherBuilder xlinq::gather </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers elements of collection. </p>
<p>This function allows to gather elements of collection to improve query performance, or to copy collection elements preventing from deallocating enumeration source collection. It is used to intentionally omit effects, advantages and disadvantages of deffered execution. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of gather expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a584dee55e0e1bb36c76f963eadddd910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GetEndEnumeratorBuilder xlinq::getEndEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function extracting end enumerator from bidirectional enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of getEndEnumerator expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a29c51dfbb405e91dbf589ba4864d700c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GetEnumeratorBuilder xlinq::getEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function extracting enumerator from enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of getEnumerator expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aff22f546b38f9e0a88fd478b8710b6c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GetEnumeratorAtBuilder xlinq::getEnumeratorAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function extracting enumerator at given position from random access enumerable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementIndex</td><td>index of element to set enumerator pointing to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of getEnumeratorAt expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a73c0c48c2ddd55173be4d492f7b72590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_LastBuilder xlinq::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts last element of collection. </p>
<p>This function may be used to extract last element of collection. It will throw <a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a> if collection contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of last expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f2c6ff34dff175b89b7b0779e131b91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValue , typename TBuilder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TValue &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBuilder&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(build(obj, builder))
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nice syntax operator for executing xlinq command. </p>
<p>This operator should be used to build xlinq queries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The enumeration object. It should be pointer to <a class="el" href="classxlinq_1_1IEnumerable.html" title="Interface for enumerable. ">IEnumerable</a> or deriving class. </td></tr>
    <tr><td class="paramname">builder</td><td>The expression builder object. It should have build method defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab738e44970df0cc013b01175278396ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::_SelectBuilder&lt;TSelector&gt; xlinq::select </td>
          <td>(</td>
          <td class="paramtype">TSelector&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts collection elements from one form to another. </p>
<p>This function may be used to create collection of elements of one type from collection of emelents of another type. It is implemented using deffered execution so traversing of the source enumerable will wait until its next element will be requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>Function used to convert elements of source collection to elements of result collection. It is common to use lambda expression as selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of select expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a56fb6711f909024ee9f1b37f006858ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::_SelectManyBuilder&lt;TSelector&gt; xlinq::select_many </td>
          <td>(</td>
          <td class="paramtype">TSelector&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens collection by concatenating subelements of original collection. </p>
<p>This function may be used to create collection from collection of collections by concatenating results of each original collection subelements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>Function used to convert each element of source collection to collection which will be selected into result collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of select_many expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a439f2d6992edc6ceb1d4457168f7d7b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::_WhereBuilder&lt;TPredicate&gt; xlinq::where </td>
          <td>(</td>
          <td class="paramtype">TPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters elements of collection using predicate. </p>
<p>This function may be used to filter collection elements using given condition. It is implemented using deffered execution. The traversing of collection in looking for next element passing given criteria stops until next element will be requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Function used to filter elements of source collection. It is common to use lambda expression as selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of select expression. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated for xLinq by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
