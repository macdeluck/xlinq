<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>xLinq: xlinq Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xLinq
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xlinq Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IEnumerator.html">IEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for enumerator.  <a href="classxlinq_1_1IEnumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IBidirectionalEnumerator.html">IBidirectionalEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for bidirectional enumerator.  <a href="classxlinq_1_1IBidirectionalEnumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IRandomAccessEnumerator.html">IRandomAccessEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for random access enumerator.  <a href="classxlinq_1_1IRandomAccessEnumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IEnumerable.html">IEnumerable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for enumerable.  <a href="classxlinq_1_1IEnumerable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IBidirectionalEnumerable.html">IBidirectionalEnumerable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for bidirectional enumerable.  <a href="classxlinq_1_1IBidirectionalEnumerable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html">IRandomAccessEnumerable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for random access enumerable.  <a href="classxlinq_1_1IRandomAccessEnumerable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IGrouping.html">IGrouping</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface representing grouping which is collection gathered by key.  <a href="classxlinq_1_1IGrouping.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxlinq_1_1array__size.html">array_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates total size of any dimension array.  <a href="structxlinq_1_1array__size.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxlinq_1_1array__size_3_01T[S]_4.html">array_size&lt; T[S]&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates total size of any dimension array.  <a href="structxlinq_1_1array__size_3_01T[S]_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxlinq_1_1unaryreturntype.html">unaryreturntype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves return type of unary function of given type.  <a href="structxlinq_1_1unaryreturntype.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxlinq_1_1binaryreturntype.html">binaryreturntype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves return type of binary function of given type.  <a href="structxlinq_1_1binaryreturntype.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1Enumerable.html">Enumerable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classxlinq_1_1Enumerable.html" title="Enumerable definitions. ">Enumerable</a> definitions.  <a href="classxlinq_1_1Enumerable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all exceptions.  <a href="classxlinq_1_1Exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IterationNotStartedException.html">IterationNotStartedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error indicating, that iteration was not started yet.  <a href="classxlinq_1_1IterationNotStartedException.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IterationFinishedException.html">IterationFinishedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error indicating, that iteration has been already finished.  <a href="classxlinq_1_1IterationFinishedException.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1KeyNotFoundException.html">KeyNotFoundException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error indicating that required key was not found in given source.  <a href="classxlinq_1_1KeyNotFoundException.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1e21281b58fabf0108275722e80b0785"><td class="memTemplParams" colspan="2">template&lt;typename TAggregator &gt; </td></tr>
<tr class="memitem:a1e21281b58fabf0108275722e80b0785"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_AggregateBuilder<br class="typebreak"/>
&lt; TAggregator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a1e21281b58fabf0108275722e80b0785">aggregate</a> (TAggregator aggregator)</td></tr>
<tr class="memdesc:a1e21281b58fabf0108275722e80b0785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates collection elements using given function.  <a href="#a1e21281b58fabf0108275722e80b0785">More...</a><br/></td></tr>
<tr class="separator:a1e21281b58fabf0108275722e80b0785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8550cfdb369cedb4b9b07a1f66fd498"><td class="memTemplParams" colspan="2">template&lt;typename TResult , typename TAggregator &gt; </td></tr>
<tr class="memitem:ad8550cfdb369cedb4b9b07a1f66fd498"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_AggregateResultBuilder<br class="typebreak"/>
&lt; TResult, TAggregator &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ad8550cfdb369cedb4b9b07a1f66fd498">aggregate</a> (TResult seed, TAggregator aggregator)</td></tr>
<tr class="memdesc:ad8550cfdb369cedb4b9b07a1f66fd498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates collection elements to any element type using given function and seed.  <a href="#ad8550cfdb369cedb4b9b07a1f66fd498">More...</a><br/></td></tr>
<tr class="separator:ad8550cfdb369cedb4b9b07a1f66fd498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7522bac658e1e418b98d363394d41876"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:a7522bac658e1e418b98d363394d41876"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_AllBuilder<br class="typebreak"/>
&lt; TPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a7522bac658e1e418b98d363394d41876">all</a> (TPredicate predicate)</td></tr>
<tr class="memdesc:a7522bac658e1e418b98d363394d41876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all collection elements satysfy given condition.  <a href="#a7522bac658e1e418b98d363394d41876">More...</a><br/></td></tr>
<tr class="separator:a7522bac658e1e418b98d363394d41876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ec2f776e1e1cf47cba4caf3c3f8a92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_AnyBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a31ec2f776e1e1cf47cba4caf3c3f8a92">any</a> ()</td></tr>
<tr class="memdesc:a31ec2f776e1e1cf47cba4caf3c3f8a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if collection contains any element.  <a href="#a31ec2f776e1e1cf47cba4caf3c3f8a92">More...</a><br/></td></tr>
<tr class="separator:a31ec2f776e1e1cf47cba4caf3c3f8a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13873b931c438d8d141525da818e63e9"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:a13873b931c438d8d141525da818e63e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_AnyPredicateBuilder<br class="typebreak"/>
&lt; TPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a13873b931c438d8d141525da818e63e9">any</a> (TPredicate predicate)</td></tr>
<tr class="memdesc:a13873b931c438d8d141525da818e63e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if collection contains any element satysfaing predicate.  <a href="#a13873b931c438d8d141525da818e63e9">More...</a><br/></td></tr>
<tr class="separator:a13873b931c438d8d141525da818e63e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95766c1fee43377ae641827f6453584"><td class="memTemplParams" colspan="2">template&lt;typename TAvgElem &gt; </td></tr>
<tr class="memitem:af95766c1fee43377ae641827f6453584"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_AvgBuilder<br class="typebreak"/>
&lt; TAvgElem &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#af95766c1fee43377ae641827f6453584">avg</a> ()</td></tr>
<tr class="memdesc:af95766c1fee43377ae641827f6453584"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates average value of collection elements.  <a href="#af95766c1fee43377ae641827f6453584">More...</a><br/></td></tr>
<tr class="separator:af95766c1fee43377ae641827f6453584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2c6ff34dff175b89b7b0779e131b91"><td class="memTemplParams" colspan="2">template&lt;typename TValue , typename TBuilder &gt; </td></tr>
<tr class="memitem:a4f2c6ff34dff175b89b7b0779e131b91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a4f2c6ff34dff175b89b7b0779e131b91">operator&gt;&gt;</a> (std::shared_ptr&lt; TValue &gt; obj, TBuilder builder) -&gt; decltype(build(obj, builder))</td></tr>
<tr class="memdesc:a4f2c6ff34dff175b89b7b0779e131b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nice syntax operator for executing xlinq command.  <a href="#a4f2c6ff34dff175b89b7b0779e131b91">More...</a><br/></td></tr>
<tr class="separator:a4f2c6ff34dff175b89b7b0779e131b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c51dfbb405e91dbf589ba4864d700c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GetEnumeratorBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a29c51dfbb405e91dbf589ba4864d700c">getEnumerator</a> ()</td></tr>
<tr class="memdesc:a29c51dfbb405e91dbf589ba4864d700c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function extracting enumerator from enumerable.  <a href="#a29c51dfbb405e91dbf589ba4864d700c">More...</a><br/></td></tr>
<tr class="separator:a29c51dfbb405e91dbf589ba4864d700c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584dee55e0e1bb36c76f963eadddd910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GetEndEnumeratorBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a584dee55e0e1bb36c76f963eadddd910">getEndEnumerator</a> ()</td></tr>
<tr class="memdesc:a584dee55e0e1bb36c76f963eadddd910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function extracting end enumerator from bidirectional enumerable.  <a href="#a584dee55e0e1bb36c76f963eadddd910">More...</a><br/></td></tr>
<tr class="separator:a584dee55e0e1bb36c76f963eadddd910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff22f546b38f9e0a88fd478b8710b6c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GetEnumeratorAtBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aff22f546b38f9e0a88fd478b8710b6c0">getEnumeratorAt</a> (int elementIndex)</td></tr>
<tr class="memdesc:aff22f546b38f9e0a88fd478b8710b6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function extracting enumerator at given position from random access enumerable.  <a href="#aff22f546b38f9e0a88fd478b8710b6c0">More...</a><br/></td></tr>
<tr class="separator:aff22f546b38f9e0a88fd478b8710b6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4334e89a57a62a0fb827ab027bb54795"><td class="memTemplParams" colspan="2">template&lt;typename TElem , int SIZE&gt; </td></tr>
<tr class="memitem:a4334e89a57a62a0fb827ab027bb54795"><td class="memTemplItemLeft" align="right" valign="top">internal::_ConcatRandomAccessBuilder<br class="typebreak"/>
&lt; TElem &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a4334e89a57a62a0fb827ab027bb54795">concat</a> (TElem(&amp;array)[SIZE])</td></tr>
<tr class="memdesc:a4334e89a57a62a0fb827ab027bb54795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function concatenating array with other enumerable into single collection.  <a href="#a4334e89a57a62a0fb827ab027bb54795">More...</a><br/></td></tr>
<tr class="separator:a4334e89a57a62a0fb827ab027bb54795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad102ec5f3d28670c209fd553e424f5a4"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:ad102ec5f3d28670c209fd553e424f5a4"><td class="memTemplItemLeft" align="right" valign="top">internal::ConcatBuilderSelector<br class="typebreak"/>
&lt; TContainer, typename <br class="typebreak"/>
TContainer::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ad102ec5f3d28670c209fd553e424f5a4">concat</a> (TContainer &amp;container)</td></tr>
<tr class="memdesc:ad102ec5f3d28670c209fd553e424f5a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function concatenating container with other enumerable into single collection.  <a href="#ad102ec5f3d28670c209fd553e424f5a4">More...</a><br/></td></tr>
<tr class="separator:ad102ec5f3d28670c209fd553e424f5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec6bf504683e98b901859ac21ab214a"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:a2ec6bf504683e98b901859ac21ab214a"><td class="memTemplItemLeft" align="right" valign="top">internal::ConcatBuilderSelector<br class="typebreak"/>
&lt; TContainer, typename <br class="typebreak"/>
TContainer::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a2ec6bf504683e98b901859ac21ab214a">concat</a> (TContainer *container)</td></tr>
<tr class="memdesc:a2ec6bf504683e98b901859ac21ab214a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function concatenating container pointer with other enumerable into single collection.  <a href="#a2ec6bf504683e98b901859ac21ab214a">More...</a><br/></td></tr>
<tr class="separator:a2ec6bf504683e98b901859ac21ab214a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8a8f161ad682b6c08d59b0fc09cb2a"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:a3c8a8f161ad682b6c08d59b0fc09cb2a"><td class="memTemplItemLeft" align="right" valign="top">internal::ConcatBuilderSelector<br class="typebreak"/>
&lt; TContainer, typename <br class="typebreak"/>
TContainer::value_type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a3c8a8f161ad682b6c08d59b0fc09cb2a">concat</a> (std::shared_ptr&lt; TContainer &gt; container)</td></tr>
<tr class="memdesc:a3c8a8f161ad682b6c08d59b0fc09cb2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function concatenating container shared pointer with other enumerable into single collection.  <a href="#a3c8a8f161ad682b6c08d59b0fc09cb2a">More...</a><br/></td></tr>
<tr class="separator:a3c8a8f161ad682b6c08d59b0fc09cb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff0586eed8fd9d546950818aa40fb11"><td class="memTemplParams" colspan="2">template&lt;typename TEnumerable &gt; </td></tr>
<tr class="memitem:afff0586eed8fd9d546950818aa40fb11"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#afff0586eed8fd9d546950818aa40fb11">concat</a> (std::shared_ptr&lt; TEnumerable &gt; enumerable) -&gt; typename internal::ConcatBuilderSelectorHelper&lt; decltype(<a class="el" href="namespacexlinq.html#aa014597a96853a8eb464f63a8e2560db">from</a>(enumerable)), typename TEnumerable::ElemType &gt;::builder</td></tr>
<tr class="memdesc:afff0586eed8fd9d546950818aa40fb11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function concatenating two enumerables into single collection.  <a href="#afff0586eed8fd9d546950818aa40fb11">More...</a><br/></td></tr>
<tr class="separator:afff0586eed8fd9d546950818aa40fb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec31d8cf9c65eb9f1b5065f7f28bd68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_CountBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a9ec31d8cf9c65eb9f1b5065f7f28bd68">count</a> ()</td></tr>
<tr class="memdesc:a9ec31d8cf9c65eb9f1b5065f7f28bd68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements in collection.  <a href="#a9ec31d8cf9c65eb9f1b5065f7f28bd68">More...</a><br/></td></tr>
<tr class="separator:a9ec31d8cf9c65eb9f1b5065f7f28bd68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ea3e14346bf47a9ec0f1291b0a447c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_DistinctBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ae7ea3e14346bf47a9ec0f1291b0a447c">distinct</a> ()</td></tr>
<tr class="memdesc:ae7ea3e14346bf47a9ec0f1291b0a447c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters unique elements from collection.  <a href="#ae7ea3e14346bf47a9ec0f1291b0a447c">More...</a><br/></td></tr>
<tr class="separator:ae7ea3e14346bf47a9ec0f1291b0a447c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be0962a91f43b18e42b288e3a87e9d5"><td class="memTemplParams" colspan="2">template&lt;typename TComparer &gt; </td></tr>
<tr class="memitem:a1be0962a91f43b18e42b288e3a87e9d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_DistinctWithEqCompBuilder<br class="typebreak"/>
&lt; TComparer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a1be0962a91f43b18e42b288e3a87e9d5">distinct</a> (TComparer comparer)</td></tr>
<tr class="memdesc:a1be0962a91f43b18e42b288e3a87e9d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters unique elements from collection using specified equality comparer.  <a href="#a1be0962a91f43b18e42b288e3a87e9d5">More...</a><br/></td></tr>
<tr class="separator:a1be0962a91f43b18e42b288e3a87e9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad841937a65fdeaf6e6663012d22e1fc"><td class="memTemplParams" colspan="2">template&lt;typename THasher , typename TComparer &gt; </td></tr>
<tr class="memitem:aad841937a65fdeaf6e6663012d22e1fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_DistinctFullBuilder<br class="typebreak"/>
&lt; THasher, TComparer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aad841937a65fdeaf6e6663012d22e1fc">distinct</a> (THasher hasher, TComparer comparer)</td></tr>
<tr class="memdesc:aad841937a65fdeaf6e6663012d22e1fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters unique elements from collection using specified equality comparer and hasher.  <a href="#aad841937a65fdeaf6e6663012d22e1fc">More...</a><br/></td></tr>
<tr class="separator:aad841937a65fdeaf6e6663012d22e1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b4455f5387f6bb2a06696ce3da7676"><td class="memTemplParams" colspan="2">template&lt;typename TSelector &gt; </td></tr>
<tr class="memitem:ab8b4455f5387f6bb2a06696ce3da7676"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_DistinctByBuilder<br class="typebreak"/>
&lt; TSelector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ab8b4455f5387f6bb2a06696ce3da7676">distinct_by</a> (TSelector selector)</td></tr>
<tr class="memdesc:ab8b4455f5387f6bb2a06696ce3da7676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters unique elements from collection by given selector.  <a href="#ab8b4455f5387f6bb2a06696ce3da7676">More...</a><br/></td></tr>
<tr class="separator:ab8b4455f5387f6bb2a06696ce3da7676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9821c9d37bd3a8e72eec3f18780115fb"><td class="memTemplParams" colspan="2">template&lt;typename TSelector , typename TComparer &gt; </td></tr>
<tr class="memitem:a9821c9d37bd3a8e72eec3f18780115fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_DistinctByWithEqCompBuilder<br class="typebreak"/>
&lt; TSelector, TComparer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a9821c9d37bd3a8e72eec3f18780115fb">distinct_by</a> (TSelector selector, TComparer comparer)</td></tr>
<tr class="memdesc:a9821c9d37bd3a8e72eec3f18780115fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters unique elements from collection by given selector.  <a href="#a9821c9d37bd3a8e72eec3f18780115fb">More...</a><br/></td></tr>
<tr class="separator:a9821c9d37bd3a8e72eec3f18780115fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a243fbbb1447f495e93bc94ac445121ea"><td class="memTemplParams" colspan="2">template&lt;typename TSelector , typename THasher , typename TComparer &gt; </td></tr>
<tr class="memitem:a243fbbb1447f495e93bc94ac445121ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_DistinctByFullBuilder<br class="typebreak"/>
&lt; TSelector, THasher, <br class="typebreak"/>
TComparer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a243fbbb1447f495e93bc94ac445121ea">distinct_by</a> (TSelector selector, THasher hasher, TComparer comparer)</td></tr>
<tr class="memdesc:a243fbbb1447f495e93bc94ac445121ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters unique elements from collection by given selector.  <a href="#a243fbbb1447f495e93bc94ac445121ea">More...</a><br/></td></tr>
<tr class="separator:a243fbbb1447f495e93bc94ac445121ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6951a4d487d915b4a1e5f1bd3d9c930"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_ElementAtBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aa6951a4d487d915b4a1e5f1bd3d9c930">element_at</a> (int index)</td></tr>
<tr class="memdesc:aa6951a4d487d915b4a1e5f1bd3d9c930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts element at given index.  <a href="#aa6951a4d487d915b4a1e5f1bd3d9c930">More...</a><br/></td></tr>
<tr class="separator:aa6951a4d487d915b4a1e5f1bd3d9c930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76025ea5baeacd05026549215a379a2b"><td class="memTemplParams" colspan="2">template&lt;typename TElem &gt; </td></tr>
<tr class="memitem:a76025ea5baeacd05026549215a379a2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_ElementAtOrDefaultBuilder<br class="typebreak"/>
&lt; TElem &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a76025ea5baeacd05026549215a379a2b">element_at_or_default</a> (int index, TElem defaultElem)</td></tr>
<tr class="memdesc:a76025ea5baeacd05026549215a379a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts element at given index or returns default value if it is out of range.  <a href="#a76025ea5baeacd05026549215a379a2b">More...</a><br/></td></tr>
<tr class="separator:a76025ea5baeacd05026549215a379a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921234e8bf3e9579a5aa0a81700c5660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_FirstBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a921234e8bf3e9579a5aa0a81700c5660">first</a> ()</td></tr>
<tr class="memdesc:a921234e8bf3e9579a5aa0a81700c5660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts first element of collection.  <a href="#a921234e8bf3e9579a5aa0a81700c5660">More...</a><br/></td></tr>
<tr class="separator:a921234e8bf3e9579a5aa0a81700c5660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f76899a72a76d887b9d1813ed1c71b"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:a62f76899a72a76d887b9d1813ed1c71b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_FirstPredicateBuilder<br class="typebreak"/>
&lt; TPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a62f76899a72a76d887b9d1813ed1c71b">first</a> (TPredicate predicate)</td></tr>
<tr class="memdesc:a62f76899a72a76d887b9d1813ed1c71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts first element of collection, which satisfies given condition.  <a href="#a62f76899a72a76d887b9d1813ed1c71b">More...</a><br/></td></tr>
<tr class="separator:a62f76899a72a76d887b9d1813ed1c71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab2e8b1345af67bcf3ca417ec675106"><td class="memTemplParams" colspan="2">template&lt;typename TElem &gt; </td></tr>
<tr class="memitem:a3ab2e8b1345af67bcf3ca417ec675106"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_FirstOrDefaultBuilder<br class="typebreak"/>
&lt; TElem &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a3ab2e8b1345af67bcf3ca417ec675106">first_or_default</a> (TElem defaultElem)</td></tr>
<tr class="memdesc:a3ab2e8b1345af67bcf3ca417ec675106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts first element of collection or returns provided default element.  <a href="#a3ab2e8b1345af67bcf3ca417ec675106">More...</a><br/></td></tr>
<tr class="separator:a3ab2e8b1345af67bcf3ca417ec675106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859e01a4d9df964dd9c3ac349e9ed61a"><td class="memTemplParams" colspan="2">template&lt;typename TElem , typename TPredicate &gt; </td></tr>
<tr class="memitem:a859e01a4d9df964dd9c3ac349e9ed61a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_FirstOrDefaultPredicateBuilder<br class="typebreak"/>
&lt; TElem, TPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a859e01a4d9df964dd9c3ac349e9ed61a">first_or_default</a> (TElem defaultElem, TPredicate predicate)</td></tr>
<tr class="memdesc:a859e01a4d9df964dd9c3ac349e9ed61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts first element of collection, which satisfies given condition or returns provided default element.  <a href="#a859e01a4d9df964dd9c3ac349e9ed61a">More...</a><br/></td></tr>
<tr class="separator:a859e01a4d9df964dd9c3ac349e9ed61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96961d816001f1a21a3de8483297b6b4"><td class="memTemplParams" colspan="2">template&lt;typename TElem , int SIZE&gt; </td></tr>
<tr class="memitem:a96961d816001f1a21a3de8483297b6b4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a96961d816001f1a21a3de8483297b6b4">from_array</a> (TElem(&amp;array)[SIZE]) -&gt; std::shared_ptr&lt; <a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html">IRandomAccessEnumerable</a>&lt; typename std::remove_all_extents&lt; typename std::remove_reference&lt; decltype(array)&gt;::type &gt;::type &gt;&gt;</td></tr>
<tr class="memdesc:a96961d816001f1a21a3de8483297b6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from any dimension fixed size array.  <a href="#a96961d816001f1a21a3de8483297b6b4">More...</a><br/></td></tr>
<tr class="separator:a96961d816001f1a21a3de8483297b6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa014597a96853a8eb464f63a8e2560db"><td class="memTemplParams" colspan="2">template&lt;typename TElem , int SIZE&gt; </td></tr>
<tr class="memitem:aa014597a96853a8eb464f63a8e2560db"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html">IRandomAccessEnumerable</a><br class="typebreak"/>
&lt; TElem &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aa014597a96853a8eb464f63a8e2560db">from</a> (TElem(&amp;array)[SIZE])</td></tr>
<tr class="memdesc:aa014597a96853a8eb464f63a8e2560db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from fixed size array.  <a href="#aa014597a96853a8eb464f63a8e2560db">More...</a><br/></td></tr>
<tr class="separator:aa014597a96853a8eb464f63a8e2560db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09854bf591e82bd4a0a1b09e4b5ff6e"><td class="memTemplParams" colspan="2">template&lt;typename TElem , int SIZE&gt; </td></tr>
<tr class="memitem:ad09854bf591e82bd4a0a1b09e4b5ff6e"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr<br class="typebreak"/>
&lt; <a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html">IRandomAccessEnumerable</a><br class="typebreak"/>
&lt; TElem &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ad09854bf591e82bd4a0a1b09e4b5ff6e">from</a> (std::array&lt; TElem, SIZE &gt; &amp;array)</td></tr>
<tr class="memdesc:ad09854bf591e82bd4a0a1b09e4b5ff6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from new standard fixed size array.  <a href="#ad09854bf591e82bd4a0a1b09e4b5ff6e">More...</a><br/></td></tr>
<tr class="separator:ad09854bf591e82bd4a0a1b09e4b5ff6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9338e7aee5cc2f78c4caf9109b4b6a08"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:a9338e7aee5cc2f78c4caf9109b4b6a08"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a9338e7aee5cc2f78c4caf9109b4b6a08">from</a> (TContainer &amp;container) -&gt; std::shared_ptr&lt; typename internal::EnumerableTypeSelector&lt; typename internal::StlEnumerableSelector&lt; TContainer, typename TContainer::value_type &gt;::type &gt;::type &gt;</td></tr>
<tr class="memdesc:a9338e7aee5cc2f78c4caf9109b4b6a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from STL container.  <a href="#a9338e7aee5cc2f78c4caf9109b4b6a08">More...</a><br/></td></tr>
<tr class="separator:a9338e7aee5cc2f78c4caf9109b4b6a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871b0d2fcbb5f1f19240bf4d322ed3fd"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:a871b0d2fcbb5f1f19240bf4d322ed3fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a871b0d2fcbb5f1f19240bf4d322ed3fd">from</a> (TContainer *container) -&gt; std::shared_ptr&lt; typename internal::EnumerableTypeSelector&lt; typename internal::StlEnumerableSelector&lt; TContainer, typename TContainer::value_type &gt;::type &gt;::type &gt;</td></tr>
<tr class="memdesc:a871b0d2fcbb5f1f19240bf4d322ed3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from pointer to STL container.  <a href="#a871b0d2fcbb5f1f19240bf4d322ed3fd">More...</a><br/></td></tr>
<tr class="separator:a871b0d2fcbb5f1f19240bf4d322ed3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54a43688decc1901d409d28d62f501a"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:aa54a43688decc1901d409d28d62f501a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aa54a43688decc1901d409d28d62f501a">from</a> (std::shared_ptr&lt; TContainer &gt; container) -&gt; std::shared_ptr&lt; typename internal::EnumerableTypeSelector&lt; typename internal::StlSharedPointerEnumerableSelector&lt; TContainer, typename TContainer::value_type &gt;::type &gt;::type &gt;</td></tr>
<tr class="memdesc:aa54a43688decc1901d409d28d62f501a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from shared pointer to STL container.  <a href="#aa54a43688decc1901d409d28d62f501a">More...</a><br/></td></tr>
<tr class="separator:aa54a43688decc1901d409d28d62f501a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543625f413c5d16601cc251b78eac562"><td class="memTemplParams" colspan="2">template&lt;typename TEnumerable &gt; </td></tr>
<tr class="memitem:a543625f413c5d16601cc251b78eac562"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; typename <br class="typebreak"/>
internal::EnumerableFilterHelper<br class="typebreak"/>
&lt; TEnumerable, typename <br class="typebreak"/>
TEnumerable::ElemType &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a543625f413c5d16601cc251b78eac562">from</a> (std::shared_ptr&lt; TEnumerable &gt; enumerable)</td></tr>
<tr class="memdesc:a543625f413c5d16601cc251b78eac562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from shared pointer to enumerable.  <a href="#a543625f413c5d16601cc251b78eac562">More...</a><br/></td></tr>
<tr class="separator:a543625f413c5d16601cc251b78eac562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c906f78dfc6d4f875df1328acc010b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GatherBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ad8c906f78dfc6d4f875df1328acc010b">gather</a> ()</td></tr>
<tr class="memdesc:ad8c906f78dfc6d4f875df1328acc010b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers elements of collection.  <a href="#ad8c906f78dfc6d4f875df1328acc010b">More...</a><br/></td></tr>
<tr class="separator:ad8c906f78dfc6d4f875df1328acc010b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7e04d87e3e2a92946119643a8a1b20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_LazyGatherBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a5c7e04d87e3e2a92946119643a8a1b20">lazy_gather</a> ()</td></tr>
<tr class="memdesc:a5c7e04d87e3e2a92946119643a8a1b20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers elements of collection while manually executing iteration.  <a href="#a5c7e04d87e3e2a92946119643a8a1b20">More...</a><br/></td></tr>
<tr class="separator:a5c7e04d87e3e2a92946119643a8a1b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a4531c6d8f5ed93d81082d2318f9b9"><td class="memTemplParams" colspan="2">template&lt;typename TKeySelector &gt; </td></tr>
<tr class="memitem:a45a4531c6d8f5ed93d81082d2318f9b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GroupByBuilder<br class="typebreak"/>
&lt; TKeySelector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a45a4531c6d8f5ed93d81082d2318f9b9">group_by</a> (TKeySelector keySelector)</td></tr>
<tr class="memdesc:a45a4531c6d8f5ed93d81082d2318f9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups elements by common key.  <a href="#a45a4531c6d8f5ed93d81082d2318f9b9">More...</a><br/></td></tr>
<tr class="separator:a45a4531c6d8f5ed93d81082d2318f9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503af29ed05b682ec78ecfba5ebefff5"><td class="memTemplParams" colspan="2">template&lt;typename TKeySelector , typename THasher , typename TEqComp &gt; </td></tr>
<tr class="memitem:a503af29ed05b682ec78ecfba5ebefff5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GroupByBuilderWithHashAndEqComp<br class="typebreak"/>
&lt; TKeySelector, THasher, <br class="typebreak"/>
TEqComp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a503af29ed05b682ec78ecfba5ebefff5">group_by</a> (TKeySelector keySelector, THasher hasher, TEqComp eqComp)</td></tr>
<tr class="memdesc:a503af29ed05b682ec78ecfba5ebefff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups elements by common key with specified key hasher and equality comparer.  <a href="#a503af29ed05b682ec78ecfba5ebefff5">More...</a><br/></td></tr>
<tr class="separator:a503af29ed05b682ec78ecfba5ebefff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52326de2c3b83f7e41e909a949230737"><td class="memTemplParams" colspan="2">template&lt;typename TKeySelector , typename TSelector &gt; </td></tr>
<tr class="memitem:a52326de2c3b83f7e41e909a949230737"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GroupByResultBuilder<br class="typebreak"/>
&lt; TKeySelector, TSelector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a52326de2c3b83f7e41e909a949230737">group_by</a> (TKeySelector keySelector, TSelector selector)</td></tr>
<tr class="memdesc:a52326de2c3b83f7e41e909a949230737"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups elements by common key.  <a href="#a52326de2c3b83f7e41e909a949230737">More...</a><br/></td></tr>
<tr class="separator:a52326de2c3b83f7e41e909a949230737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f9282e112a988ef774942efbd081f0"><td class="memTemplParams" colspan="2">template&lt;typename TKeySelector , typename TSelector , typename THasher , typename TEqComp &gt; </td></tr>
<tr class="memitem:ae4f9282e112a988ef774942efbd081f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GroupByResultBuilderWithHashAndEqComp<br class="typebreak"/>
&lt; TKeySelector, TSelector, <br class="typebreak"/>
THasher, TEqComp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ae4f9282e112a988ef774942efbd081f0">group_by</a> (TKeySelector keySelector, TSelector selector, THasher hasher, TEqComp eqComp)</td></tr>
<tr class="memdesc:ae4f9282e112a988ef774942efbd081f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Groups elements by common key with specified key hasher and equality comparer.  <a href="#ae4f9282e112a988ef774942efbd081f0">More...</a><br/></td></tr>
<tr class="separator:ae4f9282e112a988ef774942efbd081f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3d981235b61d0edadcb029b2dd67f9"><td class="memTemplParams" colspan="2">template&lt;typename TOuter , typename TKeySelector , typename TOuterKeySelector , typename TResultSelector &gt; </td></tr>
<tr class="memitem:a8b3d981235b61d0edadcb029b2dd67f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_JoinBuilder&lt; TOuter, <br class="typebreak"/>
TKeySelector, <br class="typebreak"/>
TOuterKeySelector, <br class="typebreak"/>
TResultSelector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a8b3d981235b61d0edadcb029b2dd67f9">join</a> (TOuter outer, TKeySelector keySelector, TOuterKeySelector outerKeySelector, TResultSelector resultSelector)</td></tr>
<tr class="memdesc:a8b3d981235b61d0edadcb029b2dd67f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlates elements of two collections by common key.  <a href="#a8b3d981235b61d0edadcb029b2dd67f9">More...</a><br/></td></tr>
<tr class="separator:a8b3d981235b61d0edadcb029b2dd67f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08eb90fa762b70f816892f67af69f52f"><td class="memTemplParams" colspan="2">template&lt;typename TOuter , typename TKeySelector , typename TOuterKeySelector , typename TResultSelector , typename TKeyEqComp &gt; </td></tr>
<tr class="memitem:a08eb90fa762b70f816892f67af69f52f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_JoinBuilderWithKeyComp<br class="typebreak"/>
&lt; TOuter, TKeySelector, <br class="typebreak"/>
TOuterKeySelector, <br class="typebreak"/>
TResultSelector, TKeyEqComp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a08eb90fa762b70f816892f67af69f52f">join</a> (TOuter outer, TKeySelector keySelector, TOuterKeySelector outerKeySelector, TResultSelector resultSelector, TKeyEqComp keyEqComp)</td></tr>
<tr class="memdesc:a08eb90fa762b70f816892f67af69f52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlates elements of two collections by common key.  <a href="#a08eb90fa762b70f816892f67af69f52f">More...</a><br/></td></tr>
<tr class="separator:a08eb90fa762b70f816892f67af69f52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef1fc235c301beb2c98a7878a070b1d"><td class="memTemplParams" colspan="2">template&lt;typename TOuter , typename TKeySelector , typename TOuterKeySelector , typename TResultSelector , typename TKeyEqComp , typename TInnerHasher , typename TInnerEqComp , typename TOuterHasher , typename TOuterEqComp &gt; </td></tr>
<tr class="memitem:aeef1fc235c301beb2c98a7878a070b1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_JoinBuilderFull<br class="typebreak"/>
&lt; TOuter, TKeySelector, <br class="typebreak"/>
TOuterKeySelector, <br class="typebreak"/>
TResultSelector, TKeyEqComp, <br class="typebreak"/>
TInnerHasher, TInnerEqComp, <br class="typebreak"/>
TOuterHasher, TOuterEqComp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aeef1fc235c301beb2c98a7878a070b1d">join</a> (TOuter outer, TKeySelector keySelector, TOuterKeySelector outerKeySelector, TResultSelector resultSelector, TKeyEqComp keyEqComp, TInnerHasher innerHasher, TInnerEqComp innerEqComp, TOuterHasher outerHasher, TOuterEqComp outerEqComp)</td></tr>
<tr class="memdesc:aeef1fc235c301beb2c98a7878a070b1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correlates elements of two collections by common key.  <a href="#aeef1fc235c301beb2c98a7878a070b1d">More...</a><br/></td></tr>
<tr class="separator:aeef1fc235c301beb2c98a7878a070b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c0c48c2ddd55173be4d492f7b72590"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_LastBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a73c0c48c2ddd55173be4d492f7b72590">last</a> ()</td></tr>
<tr class="memdesc:a73c0c48c2ddd55173be4d492f7b72590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts last element of collection.  <a href="#a73c0c48c2ddd55173be4d492f7b72590">More...</a><br/></td></tr>
<tr class="separator:a73c0c48c2ddd55173be4d492f7b72590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31913d8c1b09ca6b6e20b2be9436a720"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:a31913d8c1b09ca6b6e20b2be9436a720"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_LastPredicateBuilder<br class="typebreak"/>
&lt; TPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a31913d8c1b09ca6b6e20b2be9436a720">last</a> (TPredicate predicate)</td></tr>
<tr class="memdesc:a31913d8c1b09ca6b6e20b2be9436a720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts last element of collection, which satisfies given condition.  <a href="#a31913d8c1b09ca6b6e20b2be9436a720">More...</a><br/></td></tr>
<tr class="separator:a31913d8c1b09ca6b6e20b2be9436a720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaaa06b72fce6c574d114e5f8b3f370a"><td class="memTemplParams" colspan="2">template&lt;typename TElem &gt; </td></tr>
<tr class="memitem:aaaaa06b72fce6c574d114e5f8b3f370a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_LastOrDefaultBuilder<br class="typebreak"/>
&lt; TElem &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aaaaa06b72fce6c574d114e5f8b3f370a">last_or_default</a> (TElem defaultElem)</td></tr>
<tr class="memdesc:aaaaa06b72fce6c574d114e5f8b3f370a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts last element of collection or returns provided default element.  <a href="#aaaaa06b72fce6c574d114e5f8b3f370a">More...</a><br/></td></tr>
<tr class="separator:aaaaa06b72fce6c574d114e5f8b3f370a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed3b43981c80d44be8877000e662767"><td class="memTemplParams" colspan="2">template&lt;typename TElem , typename TPredicate &gt; </td></tr>
<tr class="memitem:a1ed3b43981c80d44be8877000e662767"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_LastOrDefaultPredicateBuilder<br class="typebreak"/>
&lt; TElem, TPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a1ed3b43981c80d44be8877000e662767">last_or_default</a> (TElem defaultElem, TPredicate predicate)</td></tr>
<tr class="memdesc:a1ed3b43981c80d44be8877000e662767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts last element of collection, which satisfies given condition or returns provided default element.  <a href="#a1ed3b43981c80d44be8877000e662767">More...</a><br/></td></tr>
<tr class="separator:a1ed3b43981c80d44be8877000e662767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca02e5a16b47e079ee3df711e037da43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_MaxBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aca02e5a16b47e079ee3df711e037da43">max</a> ()</td></tr>
<tr class="memdesc:aca02e5a16b47e079ee3df711e037da43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts maximum element of collection.  <a href="#aca02e5a16b47e079ee3df711e037da43">More...</a><br/></td></tr>
<tr class="separator:aca02e5a16b47e079ee3df711e037da43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e27897b54000004b14067939caae6e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_MinBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a8e27897b54000004b14067939caae6e7">min</a> ()</td></tr>
<tr class="memdesc:a8e27897b54000004b14067939caae6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts minimal element of collection.  <a href="#a8e27897b54000004b14067939caae6e7">More...</a><br/></td></tr>
<tr class="separator:a8e27897b54000004b14067939caae6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34b8077cab181bfa76791f8f56cae88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_ReverseBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ad34b8077cab181bfa76791f8f56cae88">reverse</a> ()</td></tr>
<tr class="memdesc:ad34b8077cab181bfa76791f8f56cae88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reversees order of collection elements.  <a href="#ad34b8077cab181bfa76791f8f56cae88">More...</a><br/></td></tr>
<tr class="separator:ad34b8077cab181bfa76791f8f56cae88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab738e44970df0cc013b01175278396ff"><td class="memTemplParams" colspan="2">template&lt;typename TSelector &gt; </td></tr>
<tr class="memitem:ab738e44970df0cc013b01175278396ff"><td class="memTemplItemLeft" align="right" valign="top">internal::_SelectBuilder<br class="typebreak"/>
&lt; TSelector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ab738e44970df0cc013b01175278396ff">select</a> (TSelector selector)</td></tr>
<tr class="memdesc:ab738e44970df0cc013b01175278396ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts collection elements from one form to another.  <a href="#ab738e44970df0cc013b01175278396ff">More...</a><br/></td></tr>
<tr class="separator:ab738e44970df0cc013b01175278396ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fb6711f909024ee9f1b37f006858ad"><td class="memTemplParams" colspan="2">template&lt;typename TSelector &gt; </td></tr>
<tr class="memitem:a56fb6711f909024ee9f1b37f006858ad"><td class="memTemplItemLeft" align="right" valign="top">internal::_SelectManyBuilder<br class="typebreak"/>
&lt; TSelector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a56fb6711f909024ee9f1b37f006858ad">select_many</a> (TSelector selector)</td></tr>
<tr class="memdesc:a56fb6711f909024ee9f1b37f006858ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens collection by concatenating subelements of original collection.  <a href="#a56fb6711f909024ee9f1b37f006858ad">More...</a><br/></td></tr>
<tr class="separator:a56fb6711f909024ee9f1b37f006858ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1ef7add9029ca553a353fd2fdeee79"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:afc1ef7add9029ca553a353fd2fdeee79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_SkipWhileBuilder<br class="typebreak"/>
&lt; TPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#afc1ef7add9029ca553a353fd2fdeee79">skip_while</a> (TPredicate predicate)</td></tr>
<tr class="memdesc:afc1ef7add9029ca553a353fd2fdeee79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips collection elements until first element not satisfying predicate occurs.  <a href="#afc1ef7add9029ca553a353fd2fdeee79">More...</a><br/></td></tr>
<tr class="separator:afc1ef7add9029ca553a353fd2fdeee79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602e7473f6175415bcc40e7a67371fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_SkipBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a602e7473f6175415bcc40e7a67371fb6">skip</a> (int items)</td></tr>
<tr class="memdesc:a602e7473f6175415bcc40e7a67371fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortens collection by skipping specified number of elements from beginning of collection.  <a href="#a602e7473f6175415bcc40e7a67371fb6">More...</a><br/></td></tr>
<tr class="separator:a602e7473f6175415bcc40e7a67371fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e630334a679273d52c7c22ae1b4b87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_SortBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#af0e630334a679273d52c7c22ae1b4b87">sort</a> ()</td></tr>
<tr class="memdesc:af0e630334a679273d52c7c22ae1b4b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs stable sort on collection.  <a href="#af0e630334a679273d52c7c22ae1b4b87">More...</a><br/></td></tr>
<tr class="separator:af0e630334a679273d52c7c22ae1b4b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a350a99e4016d23d64a00c7c4149adf4e"><td class="memTemplParams" colspan="2">template&lt;typename TComparer &gt; </td></tr>
<tr class="memitem:a350a99e4016d23d64a00c7c4149adf4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_SortBuilderWithComp<br class="typebreak"/>
&lt; TComparer &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a350a99e4016d23d64a00c7c4149adf4e">sort</a> (TComparer comparer)</td></tr>
<tr class="memdesc:a350a99e4016d23d64a00c7c4149adf4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs stable sort on collection.  <a href="#a350a99e4016d23d64a00c7c4149adf4e">More...</a><br/></td></tr>
<tr class="separator:a350a99e4016d23d64a00c7c4149adf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fbddf94d11626d8f1fd76523883235"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_SumBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ac2fbddf94d11626d8f1fd76523883235">sum</a> ()</td></tr>
<tr class="memdesc:ac2fbddf94d11626d8f1fd76523883235"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates sum of collection elements.  <a href="#ac2fbddf94d11626d8f1fd76523883235">More...</a><br/></td></tr>
<tr class="separator:ac2fbddf94d11626d8f1fd76523883235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dfa8f864cc568360d08fac8c4ea2f1c"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:a8dfa8f864cc568360d08fac8c4ea2f1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_TakeWhileBuilder<br class="typebreak"/>
&lt; TPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a8dfa8f864cc568360d08fac8c4ea2f1c">take_while</a> (TPredicate predicate)</td></tr>
<tr class="memdesc:a8dfa8f864cc568360d08fac8c4ea2f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to enumerate collection as long as given condition holds.  <a href="#a8dfa8f864cc568360d08fac8c4ea2f1c">More...</a><br/></td></tr>
<tr class="separator:a8dfa8f864cc568360d08fac8c4ea2f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19bdc33eb3e8cdb940293862103a9fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_TakeBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aa19bdc33eb3e8cdb940293862103a9fb">take</a> (int maxItems)</td></tr>
<tr class="memdesc:aa19bdc33eb3e8cdb940293862103a9fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortens collection to have specified maximum elements.  <a href="#aa19bdc33eb3e8cdb940293862103a9fb">More...</a><br/></td></tr>
<tr class="separator:aa19bdc33eb3e8cdb940293862103a9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439f2d6992edc6ceb1d4457168f7d7b7"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:a439f2d6992edc6ceb1d4457168f7d7b7"><td class="memTemplItemLeft" align="right" valign="top">internal::_WhereBuilder<br class="typebreak"/>
&lt; TPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a439f2d6992edc6ceb1d4457168f7d7b7">where</a> (TPredicate predicate)</td></tr>
<tr class="memdesc:a439f2d6992edc6ceb1d4457168f7d7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters elements of collection using predicate.  <a href="#a439f2d6992edc6ceb1d4457168f7d7b7">More...</a><br/></td></tr>
<tr class="separator:a439f2d6992edc6ceb1d4457168f7d7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1e21281b58fabf0108275722e80b0785"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAggregator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_AggregateBuilder&lt;TAggregator&gt; xlinq::aggregate </td>
          <td>(</td>
          <td class="paramtype">TAggregator&#160;</td>
          <td class="paramname"><em>aggregator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggregates collection elements using given function. </p>
<p>This function may be used to aggregate collection elements into one result element. It will throw <a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a> if collection contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of average expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8550cfdb369cedb4b9b07a1f66fd498"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TResult , typename TAggregator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_AggregateResultBuilder&lt;TResult, TAggregator&gt; xlinq::aggregate </td>
          <td>(</td>
          <td class="paramtype">TResult&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TAggregator&#160;</td>
          <td class="paramname"><em>aggregator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aggregates collection elements to any element type using given function and seed. </p>
<p>This function may be used to aggregate collection elements into one result element of specified type. Aggregation is started with given seed. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of average expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a7522bac658e1e418b98d363394d41876"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_AllBuilder&lt;TPredicate&gt; xlinq::all </td>
          <td>(</td>
          <td class="paramtype">TPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if all collection elements satysfy given condition. </p>
<p>This function may be used to check if all collection elements satisfy provided condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Condition to satisfy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of all expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a31ec2f776e1e1cf47cba4caf3c3f8a92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_AnyBuilder xlinq::any </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if collection contains any element. </p>
<p>This function may be used check if collection is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of any expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a13873b931c438d8d141525da818e63e9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_AnyPredicateBuilder&lt;TPredicate&gt; xlinq::any </td>
          <td>(</td>
          <td class="paramtype">TPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if collection contains any element satysfaing predicate. </p>
<p>This function may be used to check if collection contains elements which will satisfy provided predicate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate function to satisfy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of any expression. </dd></dl>

</div>
</div>
<a class="anchor" id="af95766c1fee43377ae641827f6453584"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAvgElem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_AvgBuilder&lt; double &gt; xlinq::avg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates average value of collection elements. </p>
<p>This function may be used to calculate average of collection elements. It will throw <a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a> if collection contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of average expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a4334e89a57a62a0fb827ab027bb54795"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem , int SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::_ConcatRandomAccessBuilder&lt;TElem&gt; xlinq::concat </td>
          <td>(</td>
          <td class="paramtype">TElem(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[SIZE]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function concatenating array with other enumerable into single collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td><a class="el" href="classxlinq_1_1Enumerable.html" title="Enumerable definitions. ">Enumerable</a> which will be concatenated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of concat expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ad102ec5f3d28670c209fd553e424f5a4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::ConcatBuilderSelector&lt;TContainer, typename TContainer::value_type&gt;::type xlinq::concat </td>
          <td>(</td>
          <td class="paramtype">TContainer &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function concatenating container with other enumerable into single collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td><a class="el" href="classxlinq_1_1Enumerable.html" title="Enumerable definitions. ">Enumerable</a> which will be concatenated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of concat expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ec6bf504683e98b901859ac21ab214a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::ConcatBuilderSelector&lt;TContainer, typename TContainer::value_type&gt;::type xlinq::concat </td>
          <td>(</td>
          <td class="paramtype">TContainer *&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function concatenating container pointer with other enumerable into single collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td><a class="el" href="classxlinq_1_1Enumerable.html" title="Enumerable definitions. ">Enumerable</a> which will be concatenated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of concat expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a3c8a8f161ad682b6c08d59b0fc09cb2a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::ConcatBuilderSelector&lt;TContainer, typename TContainer::value_type&gt;::type xlinq::concat </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TContainer &gt;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function concatenating container shared pointer with other enumerable into single collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td><a class="el" href="classxlinq_1_1Enumerable.html" title="Enumerable definitions. ">Enumerable</a> which will be concatenated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of concat expression. </dd></dl>

</div>
</div>
<a class="anchor" id="afff0586eed8fd9d546950818aa40fb11"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEnumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::concat </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TEnumerable &gt;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td> -&gt; typename internal::ConcatBuilderSelectorHelper&lt;decltype(from(enumerable)), typename TEnumerable::ElemType&gt;::builder
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function concatenating two enumerables into single collection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td><a class="el" href="classxlinq_1_1Enumerable.html" title="Enumerable definitions. ">Enumerable</a> which will be concatenated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of concat expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ec31d8cf9c65eb9f1b5065f7f28bd68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_CountBuilder xlinq::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of elements in collection. </p>
<p>This function may be used to count number of elements in collection. It does not count elements if the collection implements <a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html" title="Interface for random access enumerable. ">IRandomAccessEnumerable</a> interface. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of first expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7ea3e14346bf47a9ec0f1291b0a447c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_DistinctBuilder xlinq::distinct </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters unique elements from collection. </p>
<p>This function may be used to create collection with unique set of elements. Elements should be equality comparable and hashable. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of distinct expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a1be0962a91f43b18e42b288e3a87e9d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComparer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_DistinctWithEqCompBuilder&lt;TComparer&gt; xlinq::distinct </td>
          <td>(</td>
          <td class="paramtype">TComparer&#160;</td>
          <td class="paramname"><em>comparer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters unique elements from collection using specified equality comparer. </p>
<p>This function may be used to create collection with unique set of elements. Elements should be hashable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comparer</td><td>Functor used to compare elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of distinct expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aad841937a65fdeaf6e6663012d22e1fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename THasher , typename TComparer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_DistinctFullBuilder&lt;THasher, TComparer&gt; xlinq::distinct </td>
          <td>(</td>
          <td class="paramtype">THasher&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TComparer&#160;</td>
          <td class="paramname"><em>comparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters unique elements from collection using specified equality comparer and hasher. </p>
<p>This function may be used to create collection with unique set of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hasher</td><td>Functor used to hash elements. </td></tr>
    <tr><td class="paramname">comparer</td><td>Functor used to compare elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of distinct expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ab8b4455f5387f6bb2a06696ce3da7676"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_DistinctByBuilder&lt;TSelector&gt; xlinq::distinct_by </td>
          <td>(</td>
          <td class="paramtype">TSelector&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters unique elements from collection by given selector. </p>
<p>This function may be used to create collection with unique set of elements by specified selector means. Elements returned by selector should be equality comparable and hashable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>Function used to extract keys from elements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of distinct_by expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a9821c9d37bd3a8e72eec3f18780115fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelector , typename TComparer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_DistinctByWithEqCompBuilder&lt;TSelector, TComparer&gt; xlinq::distinct_by </td>
          <td>(</td>
          <td class="paramtype">TSelector&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TComparer&#160;</td>
          <td class="paramname"><em>comparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters unique elements from collection by given selector. </p>
<p>This function may be used to create collection with unique set of elements by specified selector means. Elements returned by selector should be hashable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>Function used to extract keys from elements. </td></tr>
    <tr><td class="paramname">comparer</td><td>Functor used to compare keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of distinct_by expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a243fbbb1447f495e93bc94ac445121ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelector , typename THasher , typename TComparer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_DistinctByFullBuilder&lt;TSelector, THasher, TComparer&gt; xlinq::distinct_by </td>
          <td>(</td>
          <td class="paramtype">TSelector&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THasher&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TComparer&#160;</td>
          <td class="paramname"><em>comparer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters unique elements from collection by given selector. </p>
<p>This function may be used to create collection with unique set of elements by specified selector means. Elements returned by selector should be hashable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>Function used to extract keys from elements. </td></tr>
    <tr><td class="paramname">hasher</td><td>Functor used to hash keys. </td></tr>
    <tr><td class="paramname">comparer</td><td>Functor used to compare keys. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of distinct_by expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6951a4d487d915b4a1e5f1bd3d9c930"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_ElementAtBuilder xlinq::element_at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts element at given index. </p>
<p>This function may be used to extract element at given index. It will throw <a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a> if collection has less elements than specified index or <a class="el" href="classxlinq_1_1IterationNotStartedException.html" title="Error indicating, that iteration was not started yet. ">IterationNotStartedException</a> if index is negative number. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classxlinq_1_1IterationNotStartedException.html" title="Error indicating, that iteration was not started yet. ">IterationNotStartedException</a></td><td></td></tr>
    <tr><td class="paramname"><a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a></td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of element_at expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a76025ea5baeacd05026549215a379a2b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_ElementAtOrDefaultBuilder&lt;TElem&gt; xlinq::element_at_or_default </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TElem&#160;</td>
          <td class="paramname"><em>defaultElem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts element at given index or returns default value if it is out of range. </p>
<p>This function may be used to extract element at given index. It will return defaultElem if specified index is out of range. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of element_at_or_default expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a921234e8bf3e9579a5aa0a81700c5660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_FirstBuilder xlinq::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts first element of collection. </p>
<p>This function may be used to extract first element of collection. It will throw <a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a> if collection contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of first expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a62f76899a72a76d887b9d1813ed1c71b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_FirstPredicateBuilder&lt;TPredicate&gt; xlinq::first </td>
          <td>(</td>
          <td class="paramtype">TPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts first element of collection, which satisfies given condition. </p>
<p>This function may be used to find certain element in collection satisfying given condition. It will throw <a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a> if element satisfying such condition not exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate used to find certain element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of first expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ab2e8b1345af67bcf3ca417ec675106"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_FirstOrDefaultBuilder&lt;TElem&gt; xlinq::first_or_default </td>
          <td>(</td>
          <td class="paramtype">TElem&#160;</td>
          <td class="paramname"><em>defaultElem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts first element of collection or returns provided default element. </p>
<p>This function may be used to extract first element of collection or return provided default element if collection is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultElem</td><td>Default element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of first_or_default expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a859e01a4d9df964dd9c3ac349e9ed61a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem , typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_FirstOrDefaultPredicateBuilder&lt;TElem, TPredicate&gt; xlinq::first_or_default </td>
          <td>(</td>
          <td class="paramtype">TElem&#160;</td>
          <td class="paramname"><em>defaultElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts first element of collection, which satisfies given condition or returns provided default element. </p>
<p>This function may be used to find certain element in collection satisfying given condition or return provided default element if no such element exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultElem</td><td>Default element. </td></tr>
    <tr><td class="paramname">predicate</td><td>Predicate used to find certain element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of first_or_default expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a871b0d2fcbb5f1f19240bf4d322ed3fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::from </td>
          <td>(</td>
          <td class="paramtype">TContainer *&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; std::shared_ptr&lt;typename internal::EnumerableTypeSelector&lt;typename internal::StlEnumerableSelector&lt;TContainer, typename TContainer::value_type&gt;::type&gt;::type&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from pointer to STL container. </p>
<p>This function may be used to create enumerable from pointer to STL container. It is implemented using deffered execution so traversing of the collection will wait until its next element will be requested. Please note, that enumeration will fail if container will be deallocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Source STL container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxlinq_1_1Enumerable.html" title="Enumerable definitions. ">Enumerable</a> from container. </dd></dl>

</div>
</div>
<a class="anchor" id="a543625f413c5d16601cc251b78eac562"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEnumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;typename internal::EnumerableFilterHelper&lt;TEnumerable, typename TEnumerable::ElemType&gt;::type&gt; xlinq::from </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TEnumerable &gt;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from shared pointer to enumerable. </p>
<p>This function returns cleaned type from given enumerable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Source enumerable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="aa54a43688decc1901d409d28d62f501a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::from </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TContainer &gt;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; std::shared_ptr&lt;typename internal::EnumerableTypeSelector&lt;typename internal::StlSharedPointerEnumerableSelector&lt;TContainer, typename TContainer::value_type&gt;::type&gt;::type&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from shared pointer to STL container. </p>
<p>This function may be used to create enumerable from shared pointer to STL container. It is implemented using deffered execution so traversing of the collection will wait until its next element will be requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Source STL container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxlinq_1_1Enumerable.html" title="Enumerable definitions. ">Enumerable</a> from container. </dd></dl>

</div>
</div>
<a class="anchor" id="a9338e7aee5cc2f78c4caf9109b4b6a08"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::from </td>
          <td>(</td>
          <td class="paramtype">TContainer &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; std::shared_ptr&lt;typename internal::EnumerableTypeSelector&lt;typename internal::StlEnumerableSelector&lt;TContainer, typename TContainer::value_type&gt;::type&gt;::type&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from STL container. </p>
<p>This function may be used to create enumerable from STL container. It is implemented using deffered execution so traversing of the container will wait until its next element will be requested. Please note, that enumeration will fail if container will be deallocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Source container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxlinq_1_1Enumerable.html" title="Enumerable definitions. ">Enumerable</a> from container. </dd></dl>

</div>
</div>
<a class="anchor" id="aa014597a96853a8eb464f63a8e2560db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem , int SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html">IRandomAccessEnumerable</a>&lt;TElem&gt; &gt; xlinq::from </td>
          <td>(</td>
          <td class="paramtype">TElem(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[SIZE]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from fixed size array. </p>
<p>This function may be used to create enumerable from fixed size array. It is implemented using deffered execution so traversing of the array will wait until its next element will be requested. Please note, that enumeration will fail if array will be deallocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Source fixed size array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxlinq_1_1Enumerable.html" title="Enumerable definitions. ">Enumerable</a> from array. </dd></dl>

</div>
</div>
<a class="anchor" id="ad09854bf591e82bd4a0a1b09e4b5ff6e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem , int SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classxlinq_1_1IRandomAccessEnumerable.html">IRandomAccessEnumerable</a>&lt;TElem&gt; &gt; xlinq::from </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; TElem, SIZE &gt; &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from new standard fixed size array. </p>
<p>This function may be used to create enumerable from fixed size array. It is implemented using deffered execution so traversing of the array will wait until its next element will be requested. Please note, that enumeration will fail if array will be deallocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Source fixed size array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxlinq_1_1Enumerable.html" title="Enumerable definitions. ">Enumerable</a> from array. </dd></dl>

</div>
</div>
<a class="anchor" id="a96961d816001f1a21a3de8483297b6b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem , int SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::from_array </td>
          <td>(</td>
          <td class="paramtype">TElem(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[SIZE]</td><td>)</td>
          <td> -&gt;  std::shared_ptr&lt; IRandomAccessEnumerable&lt; typename std::remove_all_extents&lt; typename std::remove_reference&lt; decltype(array)&gt;::type &gt;::type &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from any dimension fixed size array. </p>
<p>This function may be used to create enumerable from fixed size array. It is implemented using deffered execution so traversing of the array will wait until its next element will be requested. Please note, that enumeration will fail if array will be deallocated. Enumeration flattens array contents to single one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Source multidimensional fixed size array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classxlinq_1_1Enumerable.html" title="Enumerable definitions. ">Enumerable</a> from array. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8c906f78dfc6d4f875df1328acc010b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GatherBuilder xlinq::gather </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers elements of collection. </p>
<p>This function allows to gather elements of collection to improve query performance, or to copy collection elements preventing from deallocating enumeration source collection. It is used to intentionally omit effects, advantages and disadvantages of deffered execution. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of gather expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a584dee55e0e1bb36c76f963eadddd910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GetEndEnumeratorBuilder xlinq::getEndEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function extracting end enumerator from bidirectional enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of getEndEnumerator expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a29c51dfbb405e91dbf589ba4864d700c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GetEnumeratorBuilder xlinq::getEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function extracting enumerator from enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of getEnumerator expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aff22f546b38f9e0a88fd478b8710b6c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GetEnumeratorAtBuilder xlinq::getEnumeratorAt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function extracting enumerator at given position from random access enumerable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elementIndex</td><td>index of element to set enumerator pointing to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of getEnumeratorAt expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a45a4531c6d8f5ed93d81082d2318f9b9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKeySelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GroupByBuilder&lt;TKeySelector&gt; xlinq::group_by </td>
          <td>(</td>
          <td class="paramtype">TKeySelector&#160;</td>
          <td class="paramname"><em>keySelector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Groups elements by common key. </p>
<p>This function may be used to group elements by common key which is extracted from them by keySelector provided by user. Key must have defined std::hash and std::equal_to type spetialization. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of group_by expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a503af29ed05b682ec78ecfba5ebefff5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKeySelector , typename THasher , typename TEqComp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GroupByBuilderWithHashAndEqComp&lt;TKeySelector, THasher, TEqComp&gt; xlinq::group_by </td>
          <td>(</td>
          <td class="paramtype">TKeySelector&#160;</td>
          <td class="paramname"><em>keySelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THasher&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEqComp&#160;</td>
          <td class="paramname"><em>eqComp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Groups elements by common key with specified key hasher and equality comparer. </p>
<p>This function may be used to group elements by common key which is extracted from them by keySelector provided by user. Key must be hashable by specified hash function and comparable with specified equality comparer. See std::hash and std::equal_to for details. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of group_by expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a52326de2c3b83f7e41e909a949230737"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKeySelector , typename TSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GroupByResultBuilder&lt;TKeySelector, TSelector&gt; xlinq::group_by </td>
          <td>(</td>
          <td class="paramtype">TKeySelector&#160;</td>
          <td class="paramname"><em>keySelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSelector&#160;</td>
          <td class="paramname"><em>selector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Groups elements by common key. </p>
<p>This function may be used to group elements by common key which is extracted from them by keySelector provided by user. Key must have defined std::hash and std::equal_to type spetialization. The grouping is transformed to form specified by user using selector. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of group_by expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ae4f9282e112a988ef774942efbd081f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TKeySelector , typename TSelector , typename THasher , typename TEqComp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GroupByResultBuilderWithHashAndEqComp&lt;TKeySelector, TSelector, THasher, TEqComp&gt; xlinq::group_by </td>
          <td>(</td>
          <td class="paramtype">TKeySelector&#160;</td>
          <td class="paramname"><em>keySelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSelector&#160;</td>
          <td class="paramname"><em>selector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">THasher&#160;</td>
          <td class="paramname"><em>hasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TEqComp&#160;</td>
          <td class="paramname"><em>eqComp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Groups elements by common key with specified key hasher and equality comparer. </p>
<p>This function may be used to group elements by common key which is extracted from them by keySelector provided by user. Key must be hashable by specified hash function and comparable with specified equality comparer. See std::hash and std::equal_to for details. The grouping is transformed to form specified by user using selector. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of group_by expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a8b3d981235b61d0edadcb029b2dd67f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TOuter , typename TKeySelector , typename TOuterKeySelector , typename TResultSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_JoinBuilder&lt;TOuter, TKeySelector, TOuterKeySelector, TResultSelector&gt; xlinq::join </td>
          <td>(</td>
          <td class="paramtype">TOuter&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TKeySelector&#160;</td>
          <td class="paramname"><em>keySelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOuterKeySelector&#160;</td>
          <td class="paramname"><em>outerKeySelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TResultSelector&#160;</td>
          <td class="paramname"><em>resultSelector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlates elements of two collections by common key. </p>
<p>This function may be used to correlate elements of two collection when theirs' keys match. Specified functions are used to extract keys from collection elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outer</td><td>Outer collection to join. </td></tr>
    <tr><td class="paramname">keySelector</td><td>Function selecting key from inner collection. </td></tr>
    <tr><td class="paramname">outerKeySelector</td><td>Function selecting key from outer collection. </td></tr>
    <tr><td class="paramname">resultSelector</td><td>Funcion selecting result. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of join expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a08eb90fa762b70f816892f67af69f52f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TOuter , typename TKeySelector , typename TOuterKeySelector , typename TResultSelector , typename TKeyEqComp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_JoinBuilderWithKeyComp&lt;TOuter, TKeySelector, TOuterKeySelector, TResultSelector, TKeyEqComp&gt; xlinq::join </td>
          <td>(</td>
          <td class="paramtype">TOuter&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TKeySelector&#160;</td>
          <td class="paramname"><em>keySelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOuterKeySelector&#160;</td>
          <td class="paramname"><em>outerKeySelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TResultSelector&#160;</td>
          <td class="paramname"><em>resultSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TKeyEqComp&#160;</td>
          <td class="paramname"><em>keyEqComp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlates elements of two collections by common key. </p>
<p>This function may be used to correlate elements of two collection when theirs' keys match. Specified functions are used to extract keys from collection elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outer</td><td>Outer collection to join. </td></tr>
    <tr><td class="paramname">keySelector</td><td>Function selecting key from inner collection. </td></tr>
    <tr><td class="paramname">outerKeySelector</td><td>Function selecting key from outer collection. </td></tr>
    <tr><td class="paramname">resultSelector</td><td>Funcion selecting result. </td></tr>
    <tr><td class="paramname">keyEqComp</td><td>Comparer of selected keys from inner and outer collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of join expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aeef1fc235c301beb2c98a7878a070b1d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TOuter , typename TKeySelector , typename TOuterKeySelector , typename TResultSelector , typename TKeyEqComp , typename TInnerHasher , typename TInnerEqComp , typename TOuterHasher , typename TOuterEqComp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_JoinBuilderFull&lt;TOuter, TKeySelector, TOuterKeySelector, TResultSelector, TKeyEqComp, TInnerHasher, TInnerEqComp, TOuterHasher, TOuterEqComp&gt; xlinq::join </td>
          <td>(</td>
          <td class="paramtype">TOuter&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TKeySelector&#160;</td>
          <td class="paramname"><em>keySelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOuterKeySelector&#160;</td>
          <td class="paramname"><em>outerKeySelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TResultSelector&#160;</td>
          <td class="paramname"><em>resultSelector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TKeyEqComp&#160;</td>
          <td class="paramname"><em>keyEqComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInnerHasher&#160;</td>
          <td class="paramname"><em>innerHasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TInnerEqComp&#160;</td>
          <td class="paramname"><em>innerEqComp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOuterHasher&#160;</td>
          <td class="paramname"><em>outerHasher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOuterEqComp&#160;</td>
          <td class="paramname"><em>outerEqComp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Correlates elements of two collections by common key. </p>
<p>This function may be used to correlate elements of two collection when theirs' keys match. Specified functions are used to extract keys from collection elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outer</td><td>Outer collection to join. </td></tr>
    <tr><td class="paramname">keySelector</td><td>Function selecting key from inner collection. </td></tr>
    <tr><td class="paramname">outerKeySelector</td><td>Function selecting key from outer collection. </td></tr>
    <tr><td class="paramname">resultSelector</td><td>Funcion selecting result. </td></tr>
    <tr><td class="paramname">keyEqComp</td><td>Comparer of selected keys from inner and outer collection. </td></tr>
    <tr><td class="paramname">innerHasher</td><td>Hasher of keys selected from inner collection. </td></tr>
    <tr><td class="paramname">innerEqComp</td><td>Comparer of keys selected from inner collection. </td></tr>
    <tr><td class="paramname">outerHasher</td><td>Hasher of keys selected from outer collection. </td></tr>
    <tr><td class="paramname">outerEqComp</td><td>Comparer of keys selected from outer collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of join expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a73c0c48c2ddd55173be4d492f7b72590"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_LastBuilder xlinq::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts last element of collection. </p>
<p>This function may be used to extract last element of collection. It will throw <a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a> if collection contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of last expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a31913d8c1b09ca6b6e20b2be9436a720"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_LastPredicateBuilder&lt;TPredicate&gt; xlinq::last </td>
          <td>(</td>
          <td class="paramtype">TPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts last element of collection, which satisfies given condition. </p>
<p>This function may be used to find last element in collection satisfying given condition. It will throw <a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a> if element satisfying such condition not exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Predicate used to find certain element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of last expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aaaaa06b72fce6c574d114e5f8b3f370a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_LastOrDefaultBuilder&lt;TElem&gt; xlinq::last_or_default </td>
          <td>(</td>
          <td class="paramtype">TElem&#160;</td>
          <td class="paramname"><em>defaultElem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts last element of collection or returns provided default element. </p>
<p>This function may be used to extract last element of collection or return provided default element if collection is empty. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultElem</td><td>Default element returned if collection is empty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of last_or_default expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ed3b43981c80d44be8877000e662767"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem , typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_LastOrDefaultPredicateBuilder&lt;TElem, TPredicate&gt; xlinq::last_or_default </td>
          <td>(</td>
          <td class="paramtype">TElem&#160;</td>
          <td class="paramname"><em>defaultElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPredicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts last element of collection, which satisfies given condition or returns provided default element. </p>
<p>This function may be used to find last element in collection satisfying given condition or return provided default element if no such element exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">defaultElem</td><td>Default element returned if collection is empty. </td></tr>
    <tr><td class="paramname">predicate</td><td>Predicate used to find certain element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of last_or_default expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c7e04d87e3e2a92946119643a8a1b20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_LazyGatherBuilder xlinq::lazy_gather </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers elements of collection while manually executing iteration. </p>
<p>Next time uses already stored elements ignoring source enumerable. This function allows to gather elements of collection to improve query performance. It is used to intentionally omit effects, advantages and disadvantages of deffered execution, allowing to store already quered items, when query is called second time ignoring source enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of gather expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aca02e5a16b47e079ee3df711e037da43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_MaxBuilder xlinq::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts maximum element of collection. </p>
<p>This function may be used to extract maximum element of collection. It will throw <a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a> if collection contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of max expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a8e27897b54000004b14067939caae6e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_MinBuilder xlinq::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts minimal element of collection. </p>
<p>This function may be used to extract minimal element of collection. It will throw <a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a> if collection contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of min expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f2c6ff34dff175b89b7b0779e131b91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValue , typename TBuilder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TValue &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBuilder&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(build(obj, builder))
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nice syntax operator for executing xlinq command. </p>
<p>This operator should be used to build xlinq queries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The enumeration object. It should be pointer to <a class="el" href="classxlinq_1_1IEnumerable.html" title="Interface for enumerable. ">IEnumerable</a> or deriving class. </td></tr>
    <tr><td class="paramname">builder</td><td>The expression builder object. It should have build method defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad34b8077cab181bfa76791f8f56cae88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_ReverseBuilder xlinq::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reversees order of collection elements. </p>
<p>This function may be used to reverse collection elements. The function is O(1) and does not gather collection elements until IEnumerable&lt;T&gt; is passed. If so, the function operates in O(n), where n is number of collection elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of skip_while expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ab738e44970df0cc013b01175278396ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::_SelectBuilder&lt;TSelector&gt; xlinq::select </td>
          <td>(</td>
          <td class="paramtype">TSelector&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts collection elements from one form to another. </p>
<p>This function may be used to create collection of elements of one type from collection of emelents of another type. It is implemented using deffered execution so traversing of the source enumerable will wait until its next element will be requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>Function used to convert elements of source collection to elements of result collection. It is common to use lambda expression as selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of select expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a56fb6711f909024ee9f1b37f006858ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::_SelectManyBuilder&lt;TSelector&gt; xlinq::select_many </td>
          <td>(</td>
          <td class="paramtype">TSelector&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens collection by concatenating subelements of original collection. </p>
<p>This function may be used to create collection from collection of collections by concatenating results of each original collection subelements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>Function used to convert each element of source collection to collection which will be selected into result collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of select_many expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a602e7473f6175415bcc40e7a67371fb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_SkipBuilder xlinq::skip </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortens collection by skipping specified number of elements from beginning of collection. </p>
<p>This function may be used to enumerate over contiguous elements ommiting few first elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">items</td><td>Number of elements to skip. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of skip expression. </dd></dl>

</div>
</div>
<a class="anchor" id="afc1ef7add9029ca553a353fd2fdeee79"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_SkipWhileBuilder&lt;TPredicate&gt; xlinq::skip_while </td>
          <td>(</td>
          <td class="paramtype">TPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skips collection elements until first element not satisfying predicate occurs. </p>
<p>This function may be used to filter collection elements. It allows to ommit collection elements as long as predicate returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Function used to filter elements of source collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of skip_while expression. </dd></dl>

</div>
</div>
<a class="anchor" id="af0e630334a679273d52c7c22ae1b4b87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_SortBuilder xlinq::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs stable sort on collection. </p>
<p>This function may be used to sort collection elements using standard std::stable_sort algorithm using std::less&lt;T&gt; comparer. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of sort expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a350a99e4016d23d64a00c7c4149adf4e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TComparer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_SortBuilderWithComp&lt;TComparer&gt; xlinq::sort </td>
          <td>(</td>
          <td class="paramtype">TComparer&#160;</td>
          <td class="paramname"><em>comparer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs stable sort on collection. </p>
<p>This function may be used to sort collection elements using standard std::stable_sort algorithm with specified elements comparer. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of sort expression. </dd></dl>

</div>
</div>
<a class="anchor" id="ac2fbddf94d11626d8f1fd76523883235"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_SumBuilder xlinq::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates sum of collection elements. </p>
<p>This function may be used to calculate sum of collection elements. It will throw <a class="el" href="classxlinq_1_1IterationFinishedException.html" title="Error indicating, that iteration has been already finished. ">IterationFinishedException</a> if collection contains no elements. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of sum expression. </dd></dl>

</div>
</div>
<a class="anchor" id="aa19bdc33eb3e8cdb940293862103a9fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_TakeBuilder xlinq::take </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxItems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortens collection to have specified maximum elements. </p>
<p>This function may be used to enumerate over contiguous elements from the start of a sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxItems</td><td>Maximum elements to iterate over. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of take expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dfa8f864cc568360d08fac8c4ea2f1c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_TakeWhileBuilder&lt;TPredicate&gt; xlinq::take_while </td>
          <td>(</td>
          <td class="paramtype">TPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to enumerate collection as long as given condition holds. </p>
<p>This function may be used to filter collection elements. It is possible to iterate collection as long as predicate returns true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Function used to filter elements of source collection. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of take_while expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a439f2d6992edc6ceb1d4457168f7d7b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::_WhereBuilder&lt;TPredicate&gt; xlinq::where </td>
          <td>(</td>
          <td class="paramtype">TPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters elements of collection using predicate. </p>
<p>This function may be used to filter collection elements using given condition. It is implemented using deffered execution. The traversing of collection in looking for next element passing given criteria stops until next element will be requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Function used to filter elements of source collection. It is common to use lambda expression as predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of where expression. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated for xLinq by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
