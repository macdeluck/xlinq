<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>xLinq: xlinq Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">xLinq
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">xlinq Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IEnumerator.html">IEnumerator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for enumerator.  <a href="classxlinq_1_1IEnumerator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IEnumerable.html">IEnumerable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for enumerable.  <a href="classxlinq_1_1IEnumerable.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1Exception.html">Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all exceptions.  <a href="classxlinq_1_1Exception.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IterationNotStartedException.html">IterationNotStartedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error indicating, that iteration was not started yet.  <a href="classxlinq_1_1IterationNotStartedException.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxlinq_1_1IterationFinishedException.html">IterationFinishedException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error indicating, that iteration has been already finished.  <a href="classxlinq_1_1IterationFinishedException.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4f2c6ff34dff175b89b7b0779e131b91"><td class="memTemplParams" colspan="2">template&lt;typename TValue , typename TBuilder &gt; </td></tr>
<tr class="memitem:a4f2c6ff34dff175b89b7b0779e131b91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a4f2c6ff34dff175b89b7b0779e131b91">operator&gt;&gt;</a> (std::shared_ptr&lt; TValue &gt; obj, TBuilder builder) -&gt; decltype(build(obj, builder))</td></tr>
<tr class="memdesc:a4f2c6ff34dff175b89b7b0779e131b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nice syntax operator for executing xlinq command.  <a href="#a4f2c6ff34dff175b89b7b0779e131b91">More...</a><br/></td></tr>
<tr class="separator:a4f2c6ff34dff175b89b7b0779e131b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c51dfbb405e91dbf589ba4864d700c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GetEnumeratorBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a29c51dfbb405e91dbf589ba4864d700c">getEnumerator</a> ()</td></tr>
<tr class="memdesc:a29c51dfbb405e91dbf589ba4864d700c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function extracting enumerator from enumerable.  <a href="#a29c51dfbb405e91dbf589ba4864d700c">More...</a><br/></td></tr>
<tr class="separator:a29c51dfbb405e91dbf589ba4864d700c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34419de7720a6cb04b210f1681ae9db"><td class="memTemplParams" colspan="2">template&lt;typename TElem , size_t SIZE&gt; </td></tr>
<tr class="memitem:ad34419de7720a6cb04b210f1681ae9db"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classxlinq_1_1IEnumerable.html">IEnumerable</a><br class="typebreak"/>
&lt; TElem &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ad34419de7720a6cb04b210f1681ae9db">from</a> (TElem(&amp;array)[SIZE])</td></tr>
<tr class="memdesc:ad34419de7720a6cb04b210f1681ae9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from fixed size array.  <a href="#ad34419de7720a6cb04b210f1681ae9db">More...</a><br/></td></tr>
<tr class="separator:ad34419de7720a6cb04b210f1681ae9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace159b237fbafd4ecb9b00c053389da2"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:ace159b237fbafd4ecb9b00c053389da2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ace159b237fbafd4ecb9b00c053389da2">from</a> (std::shared_ptr&lt; TContainer &gt; container) -&gt; std::shared_ptr&lt; <a class="el" href="classxlinq_1_1IEnumerable.html">IEnumerable</a>&lt; typename TContainer::value_type &gt;&gt;</td></tr>
<tr class="memdesc:ace159b237fbafd4ecb9b00c053389da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from shared pointer to STL container.  <a href="#ace159b237fbafd4ecb9b00c053389da2">More...</a><br/></td></tr>
<tr class="separator:ace159b237fbafd4ecb9b00c053389da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2da1f78a03b2d08516ba942cf30658"><td class="memTemplParams" colspan="2">template&lt;typename TEnumerable &gt; </td></tr>
<tr class="memitem:aae2da1f78a03b2d08516ba942cf30658"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#aae2da1f78a03b2d08516ba942cf30658">from</a> (std::shared_ptr&lt; TEnumerable &gt; enumerable) -&gt; std::shared_ptr&lt; <a class="el" href="classxlinq_1_1IEnumerable.html">IEnumerable</a>&lt; typename TEnumerable::ElemType &gt;&gt;</td></tr>
<tr class="memdesc:aae2da1f78a03b2d08516ba942cf30658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from shared pointer to enumerable.  <a href="#aae2da1f78a03b2d08516ba942cf30658">More...</a><br/></td></tr>
<tr class="separator:aae2da1f78a03b2d08516ba942cf30658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a976342befd0a967eee63b7d40961e"><td class="memTemplParams" colspan="2">template&lt;typename TContainer &gt; </td></tr>
<tr class="memitem:a54a976342befd0a967eee63b7d40961e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a54a976342befd0a967eee63b7d40961e">from</a> (TContainer &amp;container) -&gt; std::shared_ptr&lt; <a class="el" href="classxlinq_1_1IEnumerable.html">IEnumerable</a>&lt; typename TContainer::value_type &gt;&gt;</td></tr>
<tr class="memdesc:a54a976342befd0a967eee63b7d40961e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates enumerable from STL container.  <a href="#a54a976342befd0a967eee63b7d40961e">More...</a><br/></td></tr>
<tr class="separator:a54a976342befd0a967eee63b7d40961e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c906f78dfc6d4f875df1328acc010b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> <br class="typebreak"/>
internal::_GatherBuilder&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ad8c906f78dfc6d4f875df1328acc010b">gather</a> ()</td></tr>
<tr class="memdesc:ad8c906f78dfc6d4f875df1328acc010b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gathers elements of collection.  <a href="#ad8c906f78dfc6d4f875df1328acc010b">More...</a><br/></td></tr>
<tr class="separator:ad8c906f78dfc6d4f875df1328acc010b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab738e44970df0cc013b01175278396ff"><td class="memTemplParams" colspan="2">template&lt;typename TSelector &gt; </td></tr>
<tr class="memitem:ab738e44970df0cc013b01175278396ff"><td class="memTemplItemLeft" align="right" valign="top">internal::_SelectBuilder<br class="typebreak"/>
&lt; TSelector &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#ab738e44970df0cc013b01175278396ff">select</a> (TSelector selector)</td></tr>
<tr class="memdesc:ab738e44970df0cc013b01175278396ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts collection elements from one form to another.  <a href="#ab738e44970df0cc013b01175278396ff">More...</a><br/></td></tr>
<tr class="separator:ab738e44970df0cc013b01175278396ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439f2d6992edc6ceb1d4457168f7d7b7"><td class="memTemplParams" colspan="2">template&lt;typename TPredicate &gt; </td></tr>
<tr class="memitem:a439f2d6992edc6ceb1d4457168f7d7b7"><td class="memTemplItemLeft" align="right" valign="top">internal::_WhereBuilder<br class="typebreak"/>
&lt; TPredicate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexlinq.html#a439f2d6992edc6ceb1d4457168f7d7b7">where</a> (TPredicate predicate)</td></tr>
<tr class="memdesc:a439f2d6992edc6ceb1d4457168f7d7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters elements of collection using predicate.  <a href="#a439f2d6992edc6ceb1d4457168f7d7b7">More...</a><br/></td></tr>
<tr class="separator:a439f2d6992edc6ceb1d4457168f7d7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ad34419de7720a6cb04b210f1681ae9db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TElem , size_t SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classxlinq_1_1IEnumerable.html">IEnumerable</a>&lt;TElem&gt; &gt; xlinq::from </td>
          <td>(</td>
          <td class="paramtype">TElem(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[SIZE]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from fixed size array. </p>
<p>This function may be used to create enumerable from fixed size array. It is implemented using deffered execution so traversing of the array will wait until its next element will be requested. Please note, that enumeration will fail if array will be deallocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Source fixed size array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enumerable from array. </dd></dl>

</div>
</div>
<a class="anchor" id="ace159b237fbafd4ecb9b00c053389da2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::from </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TContainer &gt;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; std::shared_ptr&lt;IEnumerable&lt;typename TContainer::value_type&gt;&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from shared pointer to STL container. </p>
<p>This function may be used to create enumerable from pointer to STL container. It is implemented using deffered execution so traversing of the collection will wait until its next element will be requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Source STL container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enumerable from container. </dd></dl>

</div>
</div>
<a class="anchor" id="aae2da1f78a03b2d08516ba942cf30658"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TEnumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::from </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TEnumerable &gt;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td> -&gt; std::shared_ptr&lt;IEnumerable&lt;typename TEnumerable::ElemType&gt;&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from shared pointer to enumerable. </p>
<p>This function just returns given enumerable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Source enumerable </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Given pointer. </dd></dl>

</div>
</div>
<a class="anchor" id="a54a976342befd0a967eee63b7d40961e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::from </td>
          <td>(</td>
          <td class="paramtype">TContainer &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> -&gt; std::shared_ptr&lt;IEnumerable&lt;typename TContainer::value_type&gt;&gt;
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates enumerable from STL container. </p>
<p>This function may be used to create enumerable from STL container. It is implemented using deffered execution so traversing of the container will wait until its next element will be requested. Please note, that enumeration will fail if container will be deallocated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>Source container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enumerable from container. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8c906f78dfc6d4f875df1328acc010b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GatherBuilder xlinq::gather </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gathers elements of collection. </p>
<p>This function allows to gather elements of collection to improve query performance, or to copy collection elements preventing from deallocating enumeration source collection. It is used to intentionally omit effects, advantages and disadvantages of deffered execution. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of gather expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a29c51dfbb405e91dbf589ba4864d700c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="xlinq__defs_8h.html#a6318da9f1c33143464070eb48ed158b7">XLINQ_INLINE</a> internal::_GetEnumeratorBuilder xlinq::getEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function extracting enumerator from enumerable. </p>
<dl class="section return"><dt>Returns</dt><dd>Builder of getEnumerator expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f2c6ff34dff175b89b7b0779e131b91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TValue , typename TBuilder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xlinq::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; TValue &gt;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TBuilder&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(build(obj, builder))
	</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Nice syntax operator for executing xlinq command. </p>
<p>This operator should be used to build xlinq queries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The enumeration object. It should be pointer to <a class="el" href="classxlinq_1_1IEnumerable.html" title="Interface for enumerable. ">IEnumerable</a> or deriving class. </td></tr>
    <tr><td class="paramname">builder</td><td>The expression builder object. It should have build method defined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab738e44970df0cc013b01175278396ff"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::_SelectBuilder&lt;TSelector&gt; xlinq::select </td>
          <td>(</td>
          <td class="paramtype">TSelector&#160;</td>
          <td class="paramname"><em>selector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts collection elements from one form to another. </p>
<p>This function may be used to create collection of elements of one type from collection of emelents of another type. It is implemented using deffered execution so traversing of the source enumerable will wait until its next element will be requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">selector</td><td>Function used to convert elements of source collection to elements of result collection. It is common to use lambda expression as selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of select expression. </dd></dl>

</div>
</div>
<a class="anchor" id="a439f2d6992edc6ceb1d4457168f7d7b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">internal::_WhereBuilder&lt;TPredicate&gt; xlinq::where </td>
          <td>(</td>
          <td class="paramtype">TPredicate&#160;</td>
          <td class="paramname"><em>predicate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters elements of collection using predicate. </p>
<p>This function may be used to filter collection elements using given condition. It is implemented using deffered execution. The traversing of collection in looking for next element passing given criteria stops until next element will be requested. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate</td><td>Function used to filter elements of source collection. It is common to use lambda expression as selector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Builder of select expression. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated for xLinq by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
